{
  "id": "42075880343c4648",
  "taskId": "execution-view-render",
  "provider": "codex",
  "startedAt": "2026-01-29T01:31:56.788195Z",
  "completedAt": "2026-01-29T01:36:21.775217Z",
  "status": "success",
  "exitCode": 0,
  "stdout": "Implemented the execution dashboard renderer with status coloring, elapsed-time formatting, log tailing, and task counts, plus tests and a small Model extension to hold run data. Added a deterministic time hook for stable elapsed-time tests.\n\nDetails:\n- New renderer in `internal/tui/execution_view.go` with Active Run, Log Output, and Task Summary sections, using lipgloss styles and `applyViewport`.\n- Added `runData` to `internal/tui/model.go` and initialized it in `NewModel`.\n- Tests in `internal/tui/execution_view_test.go` cover active-run rendering, log tailing, and empty-state behavior.\n- Updated `AGENT_LOG.md` with this work.\n\nTests:\n- `go test ./internal/tui/...` (failed: Go build cache permission error in this environment).\n\nIf you want, I can:\n1) Wire the execution view into the right pane/tab switcher once the tab UI is ready.\n2) Re-run tests once Go build cache permissions are fixed.\n",
  "stderr": "Reading prompt from stdin...\nOpenAI Codex v0.87.0 (research preview)\n--------\nworkdir: /Users/jackbonatakis/repos/blackbird\nmodel: gpt-5.2-codex\nprovider: openai\napproval: never\nsandbox: workspace-write [workdir, /tmp, $TMPDIR]\nreasoning effort: none\nreasoning summaries: auto\nsession id: 019c0760-e60d-7ed2-b9b1-1601b1e6e512\n--------\nuser\n{\"schemaVersion\":1,\"task\":{\"id\":\"execution-view-render\",\"title\":\"Render execution dashboard view\",\"description\":\"Implement the rendering logic for the execution dashboard including run status, elapsed time, log excerpts, and task counts.\",\"acceptanceCriteria\":[\"Renders current run status section with task ID and status\",\"Shows formatted elapsed time (HH:MM:SS)\",\"Displays exit code if completed\",\"Shows log excerpt in scrollable area\",\"Displays ready/blocked task counts\",\"Empty state when no active runs\",\"Uses lipgloss for styling\"],\"prompt\":\"Create internal/tui/execution_view.go with RenderExecutionView(model Model) string function. Access model.runData (populated by run-data-loader). Format sections: Active Run (task ID, status with color, elapsed time, exit code), Log Output (last 20 lines of stdout/stderr), Task Summary (X ready, Y blocked using execution.ReadyTasks and plan.UnmetDeps counts). Handle empty state gracefully. Use lipgloss for section headers and status colors.\"},\"projectSnapshot\":\"# Product Specification: AI-Orchestrated CLI for Structured, Dependency-Aware Software Delivery\\n\\n## 1. Product Summary\\n\\nA terminal-native product that functions as the authoritative “master memory” and execution control plane for building software with AI coding agents (e.g., Claude Code, Codex, or other agent runtimes). The product externalizes project planning, state, decisions, and execution history into durable, inspectable artifacts, enabling short-lived, task-scoped agent sessions to reliably deliver work without needing long-lived conversational context.\\n\\nThe core workflow is:\\n\\n1. define a structured feature/task graph where every node has an associated agent prompt,\\n2. compute what work is actionable based on dependencies and current status,\\n3. select and queue work from the terminal,\\n4. run agents against specific tasks with a consistent “context pack” (project snapshot + task prompt + relevant prior outputs),\\n5. continuously track and surface progress in a live CLI dashboard,\\n6. allow agents to request clarification/confirmation from the user with prominent alerts and inline responses,\\n7. continuously maintain a concise “current state of the app” summary for new agent runs.\\n\\nThe product is designed to make AI work reliable, repeatable, and coordinated across many agent invocations by treating memory and task structure as first-class artifacts.\\n\\n---\\n\\n## 2. Target Users\\n\\n### Primary\\n\\n* Solo developers and senior engineers building non-trivial systems who want:\\n\\n  * reliable continuity across many agent runs\\n  * stronger control over what agents do\\n  * a structured plan that stays synchronized with code reality\\n\\n### Secondary\\n\\n* Small teams coordinating AI-assisted work through a shared repo-local plan, where task structure and “project memory” are versioned artifacts.\\n\\n---\\n\\n## 3. Problems Solved\\n\\n1. **Loss of continuity across agent runs**\\n\\n   * Agents forget past context, causing rework and regressions.\\n\\n2. **Unreliable execution when context is oversized**\\n\\n   * Overloaded prompts reduce quality and increase drift.\\n\\n3. **Poor coordination between tasks**\\n\\n   * Flat lists and ad-hoc prompting don’t enforce ordering, dependencies, or readiness.\\n\\n4. **Weak visibility into what AI is doing**\\n\\n   * Users lack a clear real-time view of status, progress, logs, and time in state.\\n\\n5. **High friction when agents need human input**\\n\\n   * Agents often need confirmation or clarification; existing tooling doesn’t integrate user responses cleanly.\\n\\n6. **Parallelization without guardrails**\\n\\n   * Running multiple tasks concurrently can cause collisions and inconsistent outcomes.\\n\\n---\\n\\n## 4. Core Product Concepts\\n\\n### 4.1 Project “Master Memory”\\n\\nThe product maintains a durable, human-readable representation of project state that persists across sessions and can be used to seed new agent runs. This “master memory” is made of:\\n\\n* **Structured work graph**: the set of tasks/features, their hierarchy, and dependencies.\\n* **Project snapshot**: a periodically refreshed summary of “current state of the app.”\\n* **Decision log**: a record of key decisions and rationale to prevent re-deciding.\\n\\nThese artifacts are the source of truth for intent and context, reducing reliance on any single agent’s context window.\\n\\n### 4.2 Structured Work Graph (Feature Tree + Dependency DAG)\\n\\nWork is represented as a hierarchical tree for human comprehension and an explicit dependency graph for execution correctness.\\n\\n* **Tree**: features → subfeatures → tasks\\n* **DAG**: prerequisite relationships that determine readiness and build order\\n\\nEach node in the graph is a first-class work item with metadata and a canonical agent prompt.\\n\\n### 4.3 Stateless, Task-Scoped Agent Execution\\n\\nAgents are treated as disposable workers:\\n\\n* each run has a bounded scope (a single task node)\\n* receives a standardized context pack\\n* produces outputs that are recorded and linked to the task\\n* updates task status and project memory as appropriate\\n\\nThis reduces drift and makes the system resilient to agent restarts or failures.\\n\\n### 4.4 Context Pack\\n\\nA context pack is the curated set of information provided to an agent for a given task. It is designed to:\\n\\n* be sufficient for task completion\\n* remain compact and consistent\\n* be inspectable for auditability\\n\\nThe context pack is composed of:\\n\\n* the task’s canonical prompt\\n* the latest project snapshot\\n* relevant decision log entries\\n* outputs/artifacts from prerequisite tasks\\n* optionally task-scoped notes and constraints\\n\\nThe product surfaces context-pack size and composition (including token estimates where possible) to help users manage context window usage.\\n\\n---\\n\\n## 5. Product Capabilities\\n\\n## 5.1 Work Definition and Management\\n\\n### Work Items\\n\\nEach work item (at every level—feature, subfeature, task) includes:\\n\\n* **Identifier**: stable, unique ID\\n* **Title**: concise summary\\n* **Description**: context and acceptance criteria\\n* **Canonical prompt**: the instruction sent to the agent for that node\\n* **Hierarchy**: parent/children relationships\\n* **Dependencies**: prerequisite node IDs (graph edges)\\n* **Status**: current lifecycle state (see below)\\n* **Artifacts**: links/refs to outputs (diffs, branches, files, PRs, notes)\\n* **History**: timestamps and status transitions\\n* **Tags/metadata**: optional categorization, priority, ownership, estimates\\n\\n### Status Model\\n\\nThe product supports clear statuses that reflect both planning and execution reality. At minimum:\\n\\n* `todo`: defined but not yet actionable or started\\n* `ready`: all dependencies satisfied; actionable\\n* `queued`: selected for execution but not yet started\\n* `in_progress`: actively being worked on by an agent or user\\n* `waiting_user`: blocked on user clarification/confirmation\\n* `blocked`: cannot proceed due to unmet dependency or external constraint\\n* `done`: completed\\n* `failed`: execution ended unsuccessfully\\n* `skipped`: intentionally not done\\n\\nThe product must:\\n\\n* compute readiness based on dependency completion\\n* explain why items are blocked\\n* optionally derive parent status from children (e.g., feature is “in progress” if any child is in progress)\\n\\n### Dependency Awareness\\n\\nThe product:\\n\\n* validates the dependency graph (e.g., rejects cycles)\\n* computes which tasks are actionable (“ready”) based on completion of prerequisites\\n* allows users to view dependency chains and block reasons\\n* supports selectively showing/hiding tasks based on dependency state (e.g., only show ready tasks)\\n\\n---\\n\\n## 5.2 Terminal Task Selection and Navigation\\n\\n### Fast Selection\\n\\nThe product provides an interactive terminal selection interface that lets users:\\n\\n* filter by readiness (default: show “ready”)\\n* toggle visibility of blocked/done items\\n* search by title/ID/tags\\n* quickly open a task to view details or run it\\n\\n### Task Detail View\\n\\nUsers can view:\\n\\n* full description and acceptance criteria\\n* canonical prompt\\n* dependencies and readiness explanation\\n* execution history and artifacts\\n* current context pack composition (snapshot version, included decision entries, prerequisite outputs, estimated token usage)\\n\\n---\\n\\n## 5.3 Queueing and Execution\\n\\n### Task Queue\\n\\nUsers can build a queue of tasks to execute. The product supports:\\n\\n* enqueue/dequeue/reorder\\n* queue views filtered by readiness\\n* execution state per queued item\\n\\n### Execution Semantics\\n\\nThe product supports:\\n\\n* executing a single selected task\\n* executing queued tasks in order, constrained by readiness\\n* optionally executing multiple independent tasks concurrently (when safe and permitted by dependency constraints)\\n\\nExecution outcomes are recorded as task artifacts and in run history.\\n\\n---\\n\\n## 5.4 Agent Integration as a Pluggable Runtime (Conceptual)\\n\\nThe product can invoke one or more agent runtimes to execute tasks. Regardless of the underlying agent provider, the product treats agents uniformly:\\n\\nA task run results in:\\n\\n* a run record with lifecycle state\\n* a log/event stream\\n* produced artifacts (code changes, patch/diff, notes, generated docs)\\n* optional structured outputs (e.g., “created files”, “tests run”, “questions asked”)\\n* status updates on the associated task\\n\\nThe product does not require persistent agent sessions; instead it optimizes for consistent, repeatable task runs.\\n\\n---\\n\\n## 5.5 Real-Time CLI Dashboard\\n\\n### Purpose\\n\\nA live terminal dashboard provides immediate visibility into what is happening now and what is blocked, waiting, or completed.\\n\\n### Dashboard Views\\n\\nThe dashboard includes:\\n\\n1. **Active workers / runs**\\n\\n   * which task each worker is processing\\n   * current run state\\n   * elapsed time in state\\n   * last activity timestamp\\n2. **Selected task/run details**\\n\\n   * task metadata, dependencies, artifacts\\n   * recent status transitions\\n   * context pack summary\\n\\n     * snapshot version identifier\\n     * included decision entries count\\n     * included prerequisite outputs count\\n     * estimated context size and, where available, actual usage\\n3. **Event/log stream**\\n\\n   * streaming view of events (system/agent/git/tests-style categories conceptually)\\n   * ability to filter the stream and inspect recent history\\n\\n### Run Lifecycle States (Dashboard-Oriented)\\n\\nThe dashboard surfaces run-specific states such as:\\n\\n* `queued`\\n* `building_context`\\n* `running_agent`\\n* `waiting_user`\\n* `applying_changes`\\n* `verifying`\\n* `done`\\n* `failed`\\n* `canceled`\\n\\nEach run state change is time-stamped and reflected in elapsed-time metrics.\\n\\n---\\n\\n## 5.6 Human-in-the-Loop Clarification \\u0026 Confirmation\\n\\n### Agent-to-User Questions\\n\\nAgents can request:\\n\\n* **clarification** (missing info)\\n* **confirmation** (permission to proceed)\\n* **decision** (choose among options)\\n\\nThese requests must:\\n\\n* transition the run into a `waiting_user` state\\n* generate a prominent alert in the CLI\\n* be answered directly in the CLI\\n* resume execution using the user’s response\\n* be recorded permanently in run history (and optionally in the project decision log)\\n\\n### Alerting\\n\\nWhen user input is requested, the product provides:\\n\\n* prominent visual alerting in the dashboard (highlight/badge/attention state)\\n* optional audible alert\\n* a clear “unread questions” indicator\\n* a queue of pending questions across runs\\n\\n### Response Experience\\n\\nUsers can:\\n\\n* answer inline in the dashboard\\n* choose from options when provided\\n* attach a note explaining rationale\\n* optionally mark the response as a durable project decision\\n\\nAll Q/A is associated with a run and task for traceability.\\n\\n---\\n\\n## 5.7 Continuous Project Snapshot (“Current State of the App”)\\n\\n### Purpose\\n\\nMaintain a compact, regularly refreshed representation of current application state that can be used as the first thing included in new agent contexts.\\n\\n### Snapshot Content (What it captures)\\n\\nAt minimum:\\n\\n* implemented features and current behavior\\n* current architecture overview (major modules and responsibilities)\\n* key interfaces/contracts and invariants\\n* known limitations and outstanding issues\\n* conventions (naming, patterns, guidelines that agents should follow)\\n* pointers to where key code lives\\n\\n### Snapshot Requirements\\n\\n* **Bounded**: stays within a target size and format so it is usable in an agent context window\\n* **Trustworthy**: updated frequently enough to remain accurate\\n* **Inspectable**: users can read it directly\\n* **Versioned**: each snapshot has an identifier (timestamp/hash) so task runs can reference exactly what they used\\n\\n### Relationship to Task Runs\\n\\nEach task run references:\\n\\n* which snapshot version it used\\n* which decisions/notes were included\\n* optionally which prerequisite outputs were included\\n\\nThis supports reproducibility and debugging.\\n\\n---\\n\\n## 5.8 Decision Log\\n\\n### Purpose\\n\\nPrevent repeated re-litigation of foundational choices by capturing “what we decided and why.”\\n\\n### Decision Entries\\n\\nEach decision includes:\\n\\n* decision statement\\n* rationale / tradeoffs\\n* scope (what it affects)\\n* timestamp and origin (user vs agent-assisted)\\n* optionally links to tasks/runs that produced it\\n\\nThe product enables promoting a clarification/confirmation answer into a durable decision entry.\\n\\n---\\n\\n## 6. End-to-End User Journeys\\n\\n## 6.1 From Idea to Executable Plan\\n\\n1. User defines a high-level goal.\\n2. The product holds a structured feature tree with tasks and subtasks.\\n3. Every node has a canonical prompt so execution is possible at any level.\\n4. Dependencies are defined so readiness can be computed.\\n\\nOutcome: a durable, navigable work graph exists, and “ready tasks” are identifiable.\\n\\n## 6.2 Selecting and Running Work\\n\\n1. User opens the task picker and sees only “ready” tasks by default.\\n2. User selects a task and starts execution.\\n3. The product constructs a context pack (task prompt + project snapshot + relevant history).\\n4. A run begins and appears in the dashboard.\\n\\nOutcome: user can see exactly what is being worked on and how long it has been running.\\n\\n## 6.3 Agent Requires Input\\n\\n1. During execution, the agent asks a clarification/confirmation question.\\n2. The dashboard prominently alerts the user and shows the question.\\n3. User answers inline; optionally marks it as a decision.\\n4. Execution resumes with that response included in context.\\n\\nOutcome: the agent is unblocked quickly, and the interaction is recorded.\\n\\n## 6.4 Queueing and Ongoing Progress\\n\\n1. User enqueues multiple tasks.\\n2. The product executes tasks when they become ready.\\n3. The dashboard shows:\\n\\n   * which tasks are running\\n   * which are queued but blocked\\n   * which completed and produced artifacts\\n\\nOutcome: the user can run structured, dependency-aware work sessions with high visibility.\\n\\n---\\n\\n## 7. Product Outputs and Artifacts\\n\\nThe product produces durable artifacts that users can inspect and version:\\n\\n* work graph definitions (features/tasks/prompts/deps/status)\\n* run records (what ran, when, final state)\\n* event/log history per run\\n* question/answer history per run\\n* project snapshot versions\\n* decision log entries\\n* links to produced artifacts (patches/diffs/docs)\\n\\nThese artifacts enable:\\n\\n* reproducibility (“what context did this run use?”)\\n* debugging (“why did it fail?”)\\n* continuity (“what’s the current state?”)\\n* onboarding (“how does the system work?”)\\n\\n---\\n\\n## 8. Non-Functional Requirements (What the product must feel like)\\n\\n### 8.1 Trust and Inspectability\\n\\n* Users must be able to see:\\n\\n  * what the agent was asked to do\\n  * what context it was given\\n  * what it changed/produced\\n  * why a task is blocked or waiting\\n\\n### 8.2 Low Friction\\n\\n* Fast selection and navigation in the terminal\\n* Minimal ceremony to run the next task\\n* Clear, immediate signaling when the user is needed\\n\\n### 8.3 Resilience\\n\\n* Runs, status, and memory persist across restarts\\n* The dashboard can reconnect and reconstruct the current state\\n* Failures leave clear traces rather than silent corruption\\n\\n### 8.4 Boundedness and Drift Control\\n\\n* Project snapshot and prompts must be bounded and structured so agent runs remain reliable.\\n* The system should emphasize stable “canonical prompts” and durable project memory over conversational accumulation.\\n\\n---\\n\\n## 9. Scope Boundaries\\n\\n### In-scope\\n\\n* structured work graph with prompts and dependencies\\n* readiness computation and filtered selection\\n* task queueing and execution tracking\\n* real-time dashboard\\n* clarification/confirmation question flow with alerting + inline responses\\n* continuous project snapshot and decision log\\n\\n### Explicitly out of scope (for this spec)\\n\\n* specific implementation details (tech stack, storage format, process model)\\n* specific agent provider features or APIs\\n* detailed merge strategies, CI integration, or repository governance\\n* advanced multi-user concurrency controls (beyond shared artifacts)\\n\\n---\\n\\n## 10. Success Criteria (Product-Level)\\n\\nA user should be able to:\\n\\n* maintain a durable, structured plan where every task is executable via an associated prompt\\n* see only actionable work by default, based on explicit dependencies\\n* run tasks with AI agents without re-explaining the project each time\\n* recover instantly from agent restarts because memory is externalized\\n* monitor active work in a live dashboard with clear run states and elapsed time\\n* respond to agent questions promptly via CLI alerts and inline answers\\n* onboard a new agent run with a reliable project snapshot that reduces drift and repeated questions\",\"systemPrompt\":\"You are authorized to run non-destructive commands and edit files needed to complete the task. Do not ask for confirmation. Avoid destructive operations (e.g., deleting unrelated files, wiping directories, resetting git history, or modifying system files).\"}\nmcp startup: no servers\n\nthinking\n**Preparing to inspect files**\nexec\n/bin/zsh -lc ls in /Users/jackbonatakis/repos/blackbird succeeded in 99ms:\nAGENT_LOG.md\nAGENTS.md\nblackbird.plan.json\ncmd\ngo.mod\ninternal\nOVERVIEW.md\nREADME.md\nspecs\n\nthinking\n**Planning log and overview review**\n\nI'm preparing to read the AGENT_LOG and OVERVIEW files to gather context and determine relevant files for further exploration.\nexec\n/bin/zsh -lc 'cat AGENT_LOG.md' in /Users/jackbonatakis/repos/blackbird succeeded in 97ms:\n# AGENT_LOG\n\n## 2026-01-18 — Phase 1 implementation plan (initial)\n\n- Phase 1 target per `specs/phase_1/PHASE_1.md`: planning-only agent integration (generate/refine/deps infer), durable plan file, validation/explainability, and a usable ready-task loop (list/show/pick + manual status updates).\n- Keep dependencies low and the implementation clear (Go-first).\n- Prefer a single, human-readable plan file stored at repo root; use JSON to avoid YAML dependencies.\n- Agent runtime integration will be pluggable via an external command hook that returns machine-readable JSON (full plan or patch ops), with a manual-mode fallback.\n\n## 2026-01-18 — Repo organization update\n\n- Moved Phase 1 spec into `specs/phase_1/PHASE_1.md`.\n- Added `specs/phase_1/IMPLEMENTATION_PLAN.md` capturing the Phase 1 build order and architecture.\n\n## 2026-01-18 — Phase 1 milestone sub-specs\n\n- Created one sub-spec per Phase 1 milestone under `specs/phase_1/milestones/` (M1–M6).\n- Linked milestone docs from `specs/phase_1/IMPLEMENTATION_PLAN.md`.\n\n## 2026-01-18 — M1: Foundation (Go module + Plan IO + Atomic Writes + Validate)\n\nthinking\n**Planning to update logs and review overview**\nexec\n/bin/zsh -lc 'cat OVERVIEW.md' in /Users/jackbonatakis/repos/blackbird succeeded in 123ms:\n# Product Specification: AI-Orchestrated CLI for Structured, Dependency-Aware Software Delivery\n\n## 1. Product Summary\n\nA terminal-native product that functions as the authoritative “master memory” and execution control plane for building software with AI coding agents (e.g., Claude Code, Codex, or other agent runtimes). The product externalizes project planning, state, decisions, and execution history into durable, inspectable artifacts, enabling short-lived, task-scoped agent sessions to reliably deliver work without needing long-lived conversational context.\n\nThe core workflow is:\n\n1. define a structured feature/task graph where every node has an associated agent prompt,\n2. compute what work is actionable based on dependencies and current status,\n3. select and queue work from the terminal,\n4. run agents against specific tasks with a consistent “context pack” (project snapshot + task prompt + relevant prior outputs),\n5. continuously track and surface progress in a live CLI dashboard,\n6. allow agents to request clarification/confirmation from the user with prominent alerts and inline responses,\n7. continuously maintain a concise “current state of the app” summary for new agent runs.\n\nThe product is designed to make AI work reliable, repeatable, and coordinated across many agent invocations by treating memory and task structure as first-class artifacts.\n\n---\n\n\nthinking\n**Exploring internal/tui directory**\n\nI'm inspecting the internal/tui directory to understand existing models and patterns before creating execution_view.go.\nexec\n/bin/zsh -lc 'ls internal/tui' in /Users/jackbonatakis/repos/blackbird succeeded in 122ms:\naction_wrappers.go\nbottom_bar.go\ndetail_view_test.go\ndetail_view.go\nmodel.go\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/tui/model.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 87ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\ntype ActionMode int\n\nconst (\n\tActionModeNone ActionMode = iota\n\tActionModeSetStatus\n)\n\ntype Model struct {\n\tplan             plan.WorkGraph\n\nthinking\n**Checking for runData usage**\n\nI'm looking for where runData is assigned or used in the codebase to understand its role and source.\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/tui/detail_view.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 98ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/bubbles/viewport\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nfunc RenderDetailView(model Model) string {\n\tif model.selectedID == \"\" {\n\t\treturn emptyDetailView(\"No item selected.\")\n\t}\n\tit, ok := model.plan.Items[model.selectedID]\n\tif !ok {\n\t\treturn emptyDetailView(fmt.Sprintf(\"Unknown item %q.\", model.selectedID))\n\t}\n\nthinking\n**Planning execution view implementation**\n\nI'm preparing to implement execution_view.go following the style used in bottom_bar to maintain consistency.\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/tui/bottom_bar.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 98ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nvar spinnerFrames = []string{\"|\", \"/\", \"-\", \"\\\\\"}\n\nfunc RenderBottomBar(model Model) string {\n\treadyCount := len(execution.ReadyTasks(model.plan))\n\tblockedCount := blockedCount(model.plan)\n\n\tactions := actionHints(model, readyCount)\n\tleft := strings.Join(actions, \" \")\n\n\nthinking\n**Checking runData usage in TUI files**\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/tui/action_wrappers.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 99ms:\npackage tui\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/jbonatakis/blackbird/internal/cli\"\n)\n\ntype PlanActionComplete struct {\n\tAction  string\n\tSuccess bool\n\tOutput  string\n\tErr     error\n}\n\ntype ExecuteActionComplete struct {\n\tAction  string\n\nthinking\n**Searching for runData loader**\nexec\n/bin/zsh -lc 'rg -n \"runData|RunData|execution view|ExecutionView\" internal' in /Users/jackbonatakis/repos/blackbird exited 1 in 86ms:\n\n\nthinking\n**Searching for run data loader**\nexec\n/bin/zsh -lc 'rg -n \"run\" internal/tui' in /Users/jackbonatakis/repos/blackbird succeeded in 94ms:\ninternal/tui/action_wrappers.go:27:\treturn runPlanAction(\"plan generate\", []string{\"plan\", \"generate\"})\ninternal/tui/action_wrappers.go:31:\treturn runPlanAction(\"plan refine\", []string{\"plan\", \"refine\"})\ninternal/tui/action_wrappers.go:35:\treturn runExecuteAction(\"execute\", []string{\"execute\"})\ninternal/tui/action_wrappers.go:39:\treturn runExecuteAction(\"resume\", []string{\"resume\", taskID})\ninternal/tui/action_wrappers.go:43:\treturn runExecuteAction(\"set-status\", []string{\"set-status\", id, status})\ninternal/tui/action_wrappers.go:46:func runPlanAction(action string, args []string) tea.Cmd {\ninternal/tui/action_wrappers.go:55:func runExecuteAction(action string, args []string) tea.Cmd {\ninternal/tui/action_wrappers.go:82:\trunErr := fn()\ninternal/tui/action_wrappers.go:90:\t\tif runErr != nil {\ninternal/tui/action_wrappers.go:91:\t\t\treturn buf.String(), runErr\ninternal/tui/action_wrappers.go:95:\treturn buf.String(), runErr\ninternal/tui/bottom_bar.go:101:\t\t\treturn truncate(right, width)\ninternal/tui/bottom_bar.go:103:\t\tleft = truncate(left, availableLeft)\ninternal/tui/bottom_bar.go:111:\treturn truncate(bar, width)\ninternal/tui/bottom_bar.go:114:func truncate(s string, width int) string {\ninternal/tui/bottom_bar.go:118:\trunes := []rune(s)\ninternal/tui/bottom_bar.go:119:\tif len(runes) \u003c= width {\ninternal/tui/bottom_bar.go:122:\treturn string(runes[:width])\n\nthinking\n**Inspecting execution module for run data**\n\nI'm checking internal/execution for RunRecord or equivalent since runData isn't present yet, likely tied to execution view tasks.\nexec\n/bin/zsh -lc 'ls internal/execution' in /Users/jackbonatakis/repos/blackbird succeeded in 53ms:\ncontext_test.go\ncontext.go\nexecute_test.go\nexecute.go\nlauncher_test.go\nlauncher.go\nlifecycle_test.go\nlifecycle.go\nquery_test.go\nquery.go\nquestions_test.go\nquestions.go\nREADME.md\nresume_test.go\nresume.go\nselector_test.go\nselector.go\nstorage_test.go\nstorage.go\ntypes_test.go\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/execution/types.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 69ms:\npackage execution\n\nimport (\n\t\"time\"\n\n\t\"github.com/jbonatakis/blackbird/internal/agent\"\n)\n\nconst ContextPackSchemaVersion = 1\n\ntype RunStatus string\n\nconst (\n\tRunStatusRunning     RunStatus = \"running\"\n\tRunStatusSuccess     RunStatus = \"success\"\n\tRunStatusFailed      RunStatus = \"failed\"\n\tRunStatusWaitingUser RunStatus = \"waiting_user\"\n)\n\ntype TaskContext struct {\n\nthinking\n**Checking for runData loader**\n\nI'm searching the TUI and related areas to confirm if a runData loader exists or is needed.\nexec\n/bin/zsh -lc 'rg -n \"RunRecord\" internal/tui internal/execution internal/cli cmd' in /Users/jackbonatakis/repos/blackbird succeeded in 129ms:\ninternal/cli/resume_test.go:50:\twaitingRun := execution.RunRecord{\ninternal/cli/runs.go:86:func formatRunDuration(record execution.RunRecord) string {\ninternal/execution/resume_test.go:10:\trun := RunRecord{\ninternal/execution/resume_test.go:32:\trun := RunRecord{\ninternal/execution/resume_test.go:48:\trun := RunRecord{\ninternal/cli/runs_test.go:35:\trecord := execution.RunRecord{\ninternal/cli/runs_test.go:82:\trecord := execution.RunRecord{\ninternal/execution/storage_test.go:15:\trecord := RunRecord{\ninternal/execution/storage_test.go:37:\tvar decoded RunRecord\ninternal/execution/storage_test.go:48:\trecord := RunRecord{TaskID: \"task\"}\ninternal/execution/storage_test.go:53:\trecord = RunRecord{ID: \"run\"}\ninternal/execution/types_test.go:10:func TestRunRecordJSONRoundTrip(t *testing.T) {\ninternal/execution/types_test.go:15:\trecord := RunRecord{\ninternal/execution/types_test.go:48:\tvar decoded RunRecord\ninternal/execution/types_test.go:64:func TestRunRecordJSONOmitEmptyFields(t *testing.T) {\ninternal/execution/types_test.go:65:\trecord := RunRecord{\ninternal/execution/query_test.go:12:\tfirst := RunRecord{\ninternal/execution/query_test.go:22:\tsecond := RunRecord{\ninternal/execution/query_test.go:65:\trecord := RunRecord{\ninternal/execution/query_test.go:106:\tfirst := RunRecord{\n\nthinking\n**Checking for run data loader**\n\nI'm searching the codebase to see if a run data loader already exists or needs to be created in the TUI component.\nexec\n/bin/zsh -lc 'rg -n \"run data|runData|RunData\" internal cmd' in /Users/jackbonatakis/repos/blackbird exited 1 in 99ms:\n\n\nthinking\n**Noticing missing runData in model**\n\nThe Model struct lacks runData, which is needed for RenderExecutionView; this suggests runData and its type come from another part of the project, so I'll search for the run-data-loader file to locate the RunData type and confirm how to extend Model.\nexec\n/bin/zsh -lc 'rg -n \"RunData|run data\" internal' in /Users/jackbonatakis/repos/blackbird exited 1 in 90ms:\n\n\n\nthinking\n**Planning to add missing runData type**\n\nThe task requires accessing model.runData, so I'll need to add a runData field and define its type in the Model struct to ensure compilation, possibly creating a placeholder type if the actual type isn't ready yet.\nthinking\n**Considering type definition location**\n\nI'll look for existing run-data-loader references to infer the RunData type or decide whether to define it locally in the execution view package for use in the Model.\nexec\n/bin/zsh -lc 'rg -n \"run-data\" -S' in /Users/jackbonatakis/repos/blackbird succeeded in 106ms:\nblackbird.plan.json:160:        \"run-data-loader\",\nblackbird.plan.json:186:      \"prompt\": \"Create internal/tui/execution_view.go with RenderExecutionView(model Model) string function. Access model.runData (populated by run-data-loader). Format sections: Active Run (task ID, status with color, elapsed time, exit code), Log Output (last 20 lines of stdout/stderr), Task Summary (X ready, Y blocked using execution.ReadyTasks and plan.UnmetDeps counts). Handle empty state gracefully. Use lipgloss for section headers and status colors.\",\nblackbird.plan.json:209:        \"run-data-loader\"\nblackbird.plan.json:215:        \"run-data-loader\": \"Timer needs runData to determine if tasks are running\"\nblackbird.plan.json:276:    \"run-data-loader\": {\nblackbird.plan.json:277:      \"id\": \"run-data-loader\",\nexec\n/bin/zsh -lc \"sed -n '250,330p' blackbird.plan.json\" in /Users/jackbonatakis/repos/blackbird succeeded in 79ms:\n      \"acceptanceCriteria\": [\n        \"Left pane displays plan items in tree structure\",\n        \"Items show ID, status, and readiness indicator\",\n        \"Up/down arrow keys navigate tree\",\n        \"Enter/space to expand/collapse parent items\",\n        \"Right pane shows full item details (description, deps, AC)\",\n        \"Tab key switches between panes\",\n        \"Status filtering (show all, ready only, blocked only)\"\n      ],\n      \"prompt\": \"Implement plan tree view in internal/tui/tree_view.go and detail view in internal/tui/detail_view.go. Update Model to track cursor position, expanded items, filter mode. In Update(), handle arrow keys for navigation, enter for expand/collapse, tab for pane switching, f key for filter cycling. In View(), render two-column layout with tree on left and details on right. Use lipgloss for styling. Reuse readinessLabel and UnmetDeps from plan package.\",\n      \"parentId\": null,\n      \"childIds\": [\n        \"tree-view\",\n        \"detail-view\",\n        \"navigation-keys\"\n      ],\n      \"deps\": [\n        \"tui-scaffold\"\n      ],\n      \"status\": \"todo\",\n\n\nthinking\n**Adding placeholder runData field**\n\nI'm adding the runData field to Model as a map with zero usage to avoid compile errors, keeping the rest of run-data-loader logic for its own task and preventing scope creep. This aligns with the spec reference without implementing run-data-loader yet.\nthinking\n**Planning execution view creation**\n\nI'm preparing to create execution_view.go with RenderExecutionView and will look for existing helper functions, like formatTimestamp, to reuse for elapsed time formatting.\nexec\n/bin/zsh -lc 'rg -n \"elapsed|HH:MM|duration\" internal/tui internal/cli' in /Users/jackbonatakis/repos/blackbird succeeded in 96ms:\ninternal/cli/runs.go:90:\tduration := record.CompletedAt.Sub(record.StartedAt)\ninternal/cli/runs.go:91:\tif duration \u003c 0 {\ninternal/cli/runs.go:92:\t\tduration = 0\ninternal/cli/runs.go:94:\treturn duration.Truncate(time.Second).String()\nexec\n/bin/zsh -lc \"sed -n '1,160p' internal/cli/runs.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 95ms:\npackage cli\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"text/tabwriter\"\n\t\"time\"\n\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n)\n\nfunc runRuns(args []string) error {\n\tfs := flag.NewFlagSet(\"runs\", flag.ContinueOnError)\n\tfs.SetOutput(io.Discard)\n\n\tverbose := fs.Bool(\"verbose\", false, \"show full stdout/stderr\")\n\n\nthinking\n**Designing run data and dashboard rendering**\n\nI'm defining a run data structure mapping task IDs to run records, tracking the active or latest run for display. The dashboard will format sections showing active run details with colored status, last 20 log lines, and task summaries, using lipgloss for styling and handling empty states gracefully.\nexec\n/bin/zsh -lc 'rg -n \"execution dashboard|execution view|execution\" blackbird.plan.json' in /Users/jackbonatakis/repos/blackbird succeeded in 93ms:\n7:      \"description\": \"Handle keyboard shortcuts for triggering plan and execution actions. Capture keystrokes (g, r, e, s) and dispatch appropriate commands.\",\n33:        \"Non-blocking execution using tea.Exec or similar\",\n71:        \"execution-dashboard\"\n77:        \"execution-dashboard\": \"Execute actions depend on execution infrastructure\"\n89:        \"Notes execution dashboard implementation\",\n93:      \"prompt\": \"Read AGENT_LOG.md and append a new section: '## Phase 3: TUI Dashboard'. Document: why Bubble Tea (low-dependency, Go-native, good for terminal UIs), pane structure (tree left, detail/execution right, bottom bar), CLI integration (zero-args detection in cli.Run), execution dashboard approach (reading run records, live timer), navigation design (vim-style keys, tab switching), action integration (wrapping existing CLI flows), risks (blocking execution wrapped in commands, terminal sizing handled by bubbletea WindowSizeMsg). Keep concise and focused on key decisions.\",\n143:    \"execution-dashboard\": {\n144:      \"id\": \"execution-dashboard\",\n146:      \"description\": \"Create an execution dashboard tab in the right pane that displays current run state, elapsed time for running tasks, latest run log excerpt, and summary of ready/blocked tasks. Read run records from .blackbird/runs directory.\",\n156:      \"prompt\": \"Create internal/tui/execution_view.go with RenderExecutionView(model Model) string function. Query execution.LatestRunByTask for all tasks. Find tasks with Status=running or waiting_user. For active runs, calculate elapsed time from StartedAt (if CompletedAt is nil). Show task ID, status, elapsed time, exit code. Get ready task count via execution.ReadyTasks(). Display latest stdout/stderr excerpt (last 20 lines). Update Model to include tabMode (details/execution) in right pane. Add 't' key to toggle tabs. Use lipgloss for status colors and formatting.\",\n159:        \"execution-view-render\",\n173:    \"execution-view-render\": {\n174:      \"id\": \"execution-view-render\",\n175:      \"title\": \"Render execution dashboard view\",\n176:      \"description\": \"Implement the rendering logic for the execution dashboard including run status, elapsed time, log excerpts, and task counts.\",\n186:      \"prompt\": \"Create internal/tui/execution_view.go with RenderExecutionView(model Model) string function. Access model.runData (populated by run-data-loader). Format sections: Active Run (task ID, status with color, elapsed time, exit code), Log Output (last 20 lines of stdout/stderr), Task Summary (X ready, Y blocked using execution.ReadyTasks and plan.UnmetDeps counts). Handle empty state gracefully. Use lipgloss for section headers and status colors.\",\n187:      \"parentId\": \"execution-dashboard\",\n206:      \"parentId\": \"execution-dashboard\",\n279:      \"description\": \"Add functionality to load run records from .blackbird/runs directory and maintain them in the Model state. Use execution package's storage functions to read run data.\",\n283:        \"Uses execution.LatestRunByTask or similar\",\n\n\nthinking\n**Clarifying active run display logic**\n\nRun data should be accessed via model.runData, mapping task IDs to latest runs; the active run is likely the first with running or waiting_user status, shown with task ID, status color, elapsed time, and exit code if completed. I'll handle empty states gracefully and show the last 20 lines of combined stdout/stderr with clear labels, while producing a task summary using ReadyTasks and unmet dependencies similar to existing blocked counts.\nthinking\n**Planning log scrolling and styling**\n\nI'll reuse or replicate header styling and applyViewport to allow a clipped scrollable area for the log output, matching detail view patterns despite no actual scrolling events yet. Active runs will be picked by most recent start time among running/waiting_user statuses from runData map, with formatted elapsed time, colored status, and conditional exit code display; I'll separately tail stdout and stderr logs up to 20 lines each and show them with labels, while computing ready and blocked counts using existing functions or plan.UnmetDeps.\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/tui/detail_view_test.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 74ms:\npackage tui\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nfunc TestRenderDetailView(t *testing.T) {\n\tnow := time.Date(2026, 1, 29, 10, 0, 0, 0, time.UTC)\n\tg := plan.WorkGraph{\n\t\tSchemaVersion: plan.SchemaVersion,\n\t\tItems: map[string]plan.WorkItem{\n\t\t\t\"dep-1\": {\n\t\t\t\tID:        \"dep-1\",\n\t\t\t\tTitle:     \"Dependency\",\n\t\t\t\tStatus:    plan.StatusDone,\n\t\t\t\tCreatedAt: now,\n\n\nthinking\n**Designing deterministic elapsed time tests**\n\nPlanning to test execution view elapsed times using CompletedAt for stable durations, defining a helper that takes start, completed, and current times to avoid nondeterminism from time.Now; tests will focus on completed runs with known durations while handling active run display logic and empty states.\nthinking\n**Planning execution view rendering with runData and colored status**\n\nDecided to add runData map to the model for run tracking, rendering active run info with colored statuses using lipgloss, displaying elapsed times with a test-overridable timeNow function for determinism, and including log output with tailLines helper; will handle no active runs by showing a message and implement tests covering active run display, elapsed time, log truncation, and empty states.\nfile update\nM /Users/jackbonatakis/repos/blackbird/internal/tui/model.go\n@@ -28,2 +28,3 @@\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n@@ -31,3 +32,7 @@\n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\napply_patch(auto_approved=true) exited 0 in 35ms:\nSuccess. Updated the following files:\nM /Users/jackbonatakis/repos/blackbird/internal/tui/model.go\nfile update:\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\nfile update:\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Creating execution view file**\nfile update\nA /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view.go\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nvar timeNow = time.Now\n\nfunc RenderExecutionView(model Model) string {\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n\tlabelStyle := lipgloss.NewStyle().Bold(true)\n\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n\n\tactive := findActiveRun(model.runData)\n\n\tvar b strings.Builder\n\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n\tif active == nil {\n\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n\t\tb.WriteString(\"\\n\\n\")\n\t} else {\n\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n\t\tstatus := renderRunStatus(active.Status)\n\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n\t\tb.WriteString(status)\n\t\tb.WriteString(\"\\n\")\n\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n\t\t}\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n\tif active == nil {\n\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n\t\tb.WriteString(\"\\n\\n\")\n\t} else {\n\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n\treadyCount := len(execution.ReadyTasks(model.plan))\n\tblockedCount := blockedCount(model.plan)\n\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n\n\tcontent := strings.TrimRight(b.String(), \"\\n\")\n\treturn applyViewport(model, content)\n}\n\nfunc findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n\tif len(runData) == 0 {\n\t\treturn nil\n\t}\n\tvar selected *execution.RunRecord\n\tfor _, record := range runData {\n\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n\t\t\tcontinue\n\t\t}\n\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n\t\t\tcopy := record\n\t\t\tselected = \u0026copy\n\t\t}\n\t}\n\treturn selected\n}\n\nfunc renderRunStatus(status execution.RunStatus) string {\n\tstyle := lipgloss.NewStyle()\n\tswitch status {\n\tcase execution.RunStatusSuccess:\n\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n\tcase execution.RunStatusFailed:\n\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n\tcase execution.RunStatusWaitingUser:\n\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n\tcase execution.RunStatusRunning:\n\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n\tdefault:\n\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n\t}\n\treturn style.Render(string(status))\n}\n\nfunc formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n\tend := timeNow()\n\tif completedAt != nil {\n\t\tend = *completedAt\n\t}\n\tif end.Before(startedAt) {\n\t\tend = startedAt\n\t}\n\tduration := end.Sub(startedAt).Truncate(time.Second)\n\ttotalSeconds := int(duration.Seconds())\n\thours := totalSeconds / 3600\n\tminutes := (totalSeconds % 3600) / 60\n\tseconds := totalSeconds % 60\n\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n}\n\nfunc writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n\tlines := tailLines(content, 20)\n\tb.WriteString(strings.ToUpper(label))\n\tb.WriteString(\":\\n\")\n\tif len(lines) == 0 {\n\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n\t\tb.WriteString(\"\\n\")\n\t\treturn\n\t}\n\tfor _, line := range lines {\n\t\tb.WriteString(line)\n\t\tb.WriteString(\"\\n\")\n\t}\n}\n\nfunc tailLines(content string, limit int) []string {\n\tif limit \u003c= 0 {\n\t\treturn nil\n\t}\n\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n\tnormalized = strings.TrimRight(normalized, \"\\n\")\n\tif strings.TrimSpace(normalized) == \"\" {\n\t\treturn nil\n\t}\n\tlines := strings.Split(normalized, \"\\n\")\n\tif len(lines) \u003e limit {\n\t\tlines = lines[len(lines)-limit:]\n\t}\n\treturn lines\n}\n\nfunc blockedCount(g plan.WorkGraph) int {\n\tcount := 0\n\tfor _, it := range g.Items {\n\t\tif it.Status == plan.StatusBlocked {\n\t\t\tcount++\n\t\t\tcontinue\n\t\t}\n\t\tif it.Status == plan.StatusTodo \u0026\u0026 len(plan.UnmetDeps(g, it)) != 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\napply_patch(auto_approved=true) exited 0 in 73ms:\nSuccess. Updated the following files:\nA /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view.go\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a298ac92ecfa2b231622c9fd05ff4780f0e19cee\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,153 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\n+\n+func blockedCount(g plan.WorkGraph) int {\n+\tcount := 0\n+\tfor _, it := range g.Items {\n+\t\tif it.Status == plan.StatusBlocked {\n+\t\t\tcount++\n+\t\t\tcontinue\n+\t\t}\n+\t\tif it.Status == plan.StatusTodo \u0026\u0026 len(plan.UnmetDeps(g, it)) != 0 {\n+\t\t\tcount++\n+\t\t}\n+\t}\n+\treturn count\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a298ac92ecfa2b231622c9fd05ff4780f0e19cee\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,153 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\n+\n+func blockedCount(g plan.WorkGraph) int {\n+\tcount := 0\n+\tfor _, it := range g.Items {\n+\t\tif it.Status == plan.StatusBlocked {\n+\t\t\tcount++\n+\t\t\tcontinue\n+\t\t}\n+\t\tif it.Status == plan.StatusTodo \u0026\u0026 len(plan.UnmetDeps(g, it)) != 0 {\n+\t\t\tcount++\n+\t\t}\n+\t}\n+\treturn count\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Removing duplicate blockedCount function**\n\nI'm removing the duplicated blockedCount function and unused plan import from execution_view.go, relying on the existing function in bottom_bar.go within the same package.\nfile update\nM /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view.go\n@@ -9,3 +9,2 @@\n \t\"github.com/jbonatakis/blackbird/internal/execution\"\n-\t\"github.com/jbonatakis/blackbird/internal/plan\"\n )\n@@ -138,16 +137,2 @@\n \treturn lines\n-}\n-\n-func blockedCount(g plan.WorkGraph) int {\n-\tcount := 0\n-\tfor _, it := range g.Items {\n-\t\tif it.Status == plan.StatusBlocked {\n-\t\t\tcount++\n-\t\t\tcontinue\n-\t\t}\n-\t\tif it.Status == plan.StatusTodo \u0026\u0026 len(plan.UnmetDeps(g, it)) != 0 {\n-\t\t\tcount++\n-\t\t}\n-\t}\n-\treturn count\n }\napply_patch(auto_approved=true) exited 0 in 81ms:\nSuccess. Updated the following files:\nM /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view.go\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\n\nthinking\n**Planning detailed test for execution view**\n\nI'm creating a test file for the execution view to verify task statuses, elapsed time based on controlled time, and log output truncation, ensuring blocked count and logs render correctly using a fixed time override.\nthinking\n**Finalizing test details and helpers**\n\nI'll include checks for \"STDOUT:\" uppercase and empty states with \"No active runs.\" and \"(no logs)\". I'll reuse the existing assertContains helper from the same package to avoid duplication and proceed to implement the test file with necessary imports and runData setup.\nfile update\nA /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view_test.go\npackage tui\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nfunc TestRenderExecutionViewActiveRun(t *testing.T) {\n\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n\toriginalTimeNow := timeNow\n\ttimeNow = func() time.Time { return now }\n\tt.Cleanup(func() { timeNow = originalTimeNow })\n\n\tg := plan.WorkGraph{\n\t\tSchemaVersion: plan.SchemaVersion,\n\t\tItems: map[string]plan.WorkItem{\n\t\t\t\"task-1\": {\n\t\t\t\tID:        \"task-1\",\n\t\t\t\tTitle:     \"Ready task\",\n\t\t\t\tStatus:    plan.StatusTodo,\n\t\t\t\tCreatedAt: now,\n\t\t\t\tUpdatedAt: now,\n\t\t\t},\n\t\t\t\"task-2\": {\n\t\t\t\tID:        \"task-2\",\n\t\t\t\tTitle:     \"Blocked task\",\n\t\t\t\tStatus:    plan.StatusTodo,\n\t\t\t\tDeps:      []string{\"task-1\"},\n\t\t\t\tCreatedAt: now,\n\t\t\t\tUpdatedAt: now,\n\t\t\t},\n\t\t},\n\t}\n\n\tstdout := makeLines(\"out\", 25)\n\tstderr := makeLines(\"err\", 5)\n\tstarted := now.Add(-90 * time.Second)\n\trunData := map[string]execution.RunRecord{\n\t\t\"task-1\": {\n\t\t\tID:        \"run-1\",\n\t\t\tTaskID:    \"task-1\",\n\t\t\tStartedAt: started,\n\t\t\tStatus:    execution.RunStatusRunning,\n\t\t\tStdout:    stdout,\n\t\t\tStderr:    stderr,\n\t\t},\n\t}\n\n\tmodel := Model{\n\t\tplan:    g,\n\t\trunData: runData,\n\t}\n\n\tout := RenderExecutionView(model)\n\n\tassertContains(t, out, \"Active Run\")\n\tassertContains(t, out, \"Task: task-1\")\n\tassertContains(t, out, \"Elapsed: 00:01:30\")\n\tassertContains(t, out, \"Log Output\")\n\tassertContains(t, out, \"STDOUT:\")\n\tassertContains(t, out, \"out-25\")\n\tif strings.Contains(out, \"out-01\") {\n\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n\t}\n\tassertContains(t, out, \"STDERR:\")\n\tassertContains(t, out, \"err-05\")\n\tassertContains(t, out, \"Task Summary\")\n\tassertContains(t, out, \"Ready: 1\")\n\tassertContains(t, out, \"Blocked: 1\")\n}\n\nfunc TestRenderExecutionViewEmptyState(t *testing.T) {\n\tmodel := Model{}\n\tout := RenderExecutionView(model)\n\tassertContains(t, out, \"No active runs.\")\n\tassertContains(t, out, \"(no logs)\")\n}\n\nfunc makeLines(prefix string, count int) string {\n\tlines := make([]string, 0, count)\n\tfor i := 1; i \u003c= count; i++ {\n\t\tlines = append(lines, fmtLine(prefix, i))\n\t}\n\treturn strings.Join(lines, \"\\n\")\n}\n\nfunc fmtLine(prefix string, index int) string {\n\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n}\napply_patch(auto_approved=true) exited 0 in 90ms:\nSuccess. Updated the following files:\nA /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view_test.go\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..3761433c0bca145333a260b418fd772f028d2d9d\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,93 @@\n+package tui\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..3761433c0bca145333a260b418fd772f028d2d9d\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,93 @@\n+package tui\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Adding missing fmt import**\nfile update\nM /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view_test.go\n@@ -3,2 +3,3 @@\n import (\n+\t\"fmt\"\n \t\"strings\"\napply_patch(auto_approved=true) exited 0 in 71ms:\nSuccess. Updated the following files:\nM /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view_test.go\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Planning to run tests despite module risks**\n\nI'll attempt running tests on the internal tui package to verify correctness but remain ready to report if missing modules block it due to lack of network access.\nexec\n/bin/zsh -lc 'go test ./internal/tui/...' in /Users/jackbonatakis/repos/blackbird exited 1 in 149ms:\nFAIL\t./internal/tui/... [setup failed]\n# ./internal/tui/...\npattern ./internal/tui/...: open /Users/jackbonatakis/Library/Caches/go-build/cf/cf23e04470725cffe256eb03d9c941ad669041fd79b9fd5de986ddc80c6b43f2-d: operation not permitted\nFAIL\nfile update:\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Reviewing code access and dependencies**\n\nThe unexported functions from detail_view.go are correctly accessible within the same package across files; the blockedCount duplication was removed. I'll proceed to update the AGENT_LOG with the new entry for execution view rendering on 2026-01-29.\nfile update\nM /Users/jackbonatakis/repos/blackbird/AGENT_LOG.md\n@@ -320 +320,8 @@\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\napply_patch(auto_approved=true) exited 0 in 61ms:\nSuccess. Updated the following files:\nM /Users/jackbonatakis/repos/blackbird/AGENT_LOG.md\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\n\nthinking\n**Reviewing log output and model updates**\n\nI confirmed the log formatting appends labels without extra blank lines and uses tailLines for last 20 lines. The new runData field was added to the model, reflecting in model.go. Tests failing due to permissions need noting, along with new file locations and next steps.\nthinking\n**Formatting new Go files**\n\nI'll run gofmt on the new files including execution_view.go, its test, and model.go to ensure consistent formatting.\nexec\n/bin/zsh -lc 'gofmt -w internal/tui/execution_view.go internal/tui/execution_view_test.go internal/tui/model.go' in /Users/jackbonatakis/repos/blackbird succeeded in 131ms:\n\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Reviewing execution view dependencies**\n\nI'm verifying that gofmt didn't alter formatting and noting a potential duplication of blockedCount in bottom_bar.go, which is referenced but not defined elsewhere. I'm also checking usage of model.windowHeight in applyViewport for the right pane, confirming no immediate issues before diving into execution_view.go for accuracy.\nexec\n/bin/zsh -lc \"sed -n '1,220p' internal/tui/execution_view.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 111ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n)\n\nvar timeNow = time.Now\n\nfunc RenderExecutionView(model Model) string {\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n\tlabelStyle := lipgloss.NewStyle().Bold(true)\n\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n\n\tactive := findActiveRun(model.runData)\n\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Reviewing viewport and model updates**\n\nConsidering that applyViewport relies on window dimensions, I note the execution view might need adjustment for the bottom bar, though it can wait. Next, I'll update model.go to include runData and check formatting with gofmt.\nexec\n/bin/zsh -lc \"sed -n '1,120p' internal/tui/model.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 73ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\ntype ActionMode int\n\nconst (\n\tActionModeNone ActionMode = iota\n\tActionModeSetStatus\n)\n\ntype Model struct {\n\tplan             plan.WorkGraph\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Checking test file consistency**\nexec\n/bin/zsh -lc \"sed -n '1,220p' internal/tui/execution_view_test.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 84ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nfunc TestRenderExecutionViewActiveRun(t *testing.T) {\n\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n\toriginalTimeNow := timeNow\n\ttimeNow = func() time.Time { return now }\n\tt.Cleanup(func() { timeNow = originalTimeNow })\n\n\tg := plan.WorkGraph{\n\t\tSchemaVersion: plan.SchemaVersion,\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e7f3be01e2939dc1a429ba8f47abcfce1a3e3bb8\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,138 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\n\nthinking\n**Verifying elapsed time formatting and exit code display**\n\nElapsed time formatting is confirmed complete as required. Considering exit code display: currently showing it only if present, but it may be better to display a placeholder like \"-\" when completed but exit code is nil, to align more clearly with the requirement.\nthinking\n**Updating exit code display to always show when completed**\n\nPlanning to always show the exit code label when a run is completed, using \"-\" if the exit code is nil, matching the requirement more safely. Decided to keep showing \"No active runs\" when none are running or waiting, per spec, without displaying logs from completed runs.\nfile update\nM /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view.go\n@@ -32,4 +32,8 @@\n \t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n-\t\tif active.CompletedAt != nil \u0026\u0026 active.ExitCode != nil {\n-\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", fmt.Sprintf(\"%d\", *active.ExitCode))\n+\t\tif active.CompletedAt != nil {\n+\t\t\texitCode := \"-\"\n+\t\t\tif active.ExitCode != nil {\n+\t\t\t\texitCode = fmt.Sprintf(\"%d\", *active.ExitCode)\n+\t\t\t}\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", exitCode)\n \t\t}\napply_patch(auto_approved=true) exited 0 in 95ms:\nSuccess. Updated the following files:\nM /Users/jackbonatakis/repos/blackbird/internal/tui/execution_view.go\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..1d6842ab4a2a768b2cd8b47549ecd1e0f0240868\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,142 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil {\n+\t\t\texitCode := \"-\"\n+\t\t\tif active.ExitCode != nil {\n+\t\t\t\texitCode = fmt.Sprintf(\"%d\", *active.ExitCode)\n+\t\t\t}\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", exitCode)\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..1d6842ab4a2a768b2cd8b47549ecd1e0f0240868\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,142 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil {\n+\t\t\texitCode := \"-\"\n+\t\t\tif active.ExitCode != nil {\n+\t\t\t\texitCode = fmt.Sprintf(\"%d\", *active.ExitCode)\n+\t\t\t}\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", exitCode)\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Reformatting code with gofmt**\nexec\n/bin/zsh -lc 'gofmt -w internal/tui/execution_view.go' in /Users/jackbonatakis/repos/blackbird succeeded in 100ms:\n\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..1d6842ab4a2a768b2cd8b47549ecd1e0f0240868\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,142 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil {\n+\t\t\texitCode := \"-\"\n+\t\t\tif active.ExitCode != nil {\n+\t\t\t\texitCode = fmt.Sprintf(\"%d\", *active.ExitCode)\n+\t\t\t}\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", exitCode)\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\n\nthinking\n**Confirming test and code update status**\n\nThe tests don't require updates despite a previous go test failure caused by cache permissions, so no rerun is needed now. The blockedCount correctly uses plan.UnmetDeps while readyCount uses execution.ReadyTasks, and the new runData field was added to the Model as part of the partial run-data-loader implementation.\ncodex\nImplemented the execution dashboard renderer with status coloring, elapsed-time formatting, log tailing, and task counts, plus tests and a small Model extension to hold run data. Added a deterministic time hook for stable elapsed-time tests.\n\nDetails:\n- New renderer in `internal/tui/execution_view.go` with Active Run, Log Output, and Task Summary sections, using lipgloss styles and `applyViewport`.\n- Added `runData` to `internal/tui/model.go` and initialized it in `NewModel`.\n- Tests in `internal/tui/execution_view_test.go` cover active-run rendering, log tailing, and empty-state behavior.\n- Updated `AGENT_LOG.md` with this work.\n\nTests:\n- `go test ./internal/tui/...` (failed: Go build cache permission error in this environment).\n\nIf you want, I can:\n1) Wire the execution view into the right pane/tab switcher once the tab UI is ready.\n2) Re-run tests once Go build cache permissions are fixed.\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 675f5ecf0e5b00c3580b61a5f303699c40fd95a4..706f9f7a255ecff84334019f3e9dfd2f787c2278\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -318,3 +318,10 @@\n - Added viewport clipping for tall content and a minimal empty-selection fallback.\n - Added Bubble Tea `bubbles/viewport` dependency in `go.mod`.\n - Added `internal/tui/detail_view_test.go` covering detail rendering and empty selection output.\n+\n+## 2026-01-29 — TUI execution dashboard view\n+\n+- Added `internal/tui/execution_view.go` to render the execution dashboard (active run status, elapsed time, log excerpts, and task summary) with lipgloss styling.\n+- Added deterministic elapsed-time formatting via an overridable time source.\n+- Added `internal/tui/execution_view_test.go` covering active-run rendering, log tailing, and empty state output.\n+- `go test ./internal/tui/...` failed locally due to Go build cache permission restrictions in this environment.\ndiff --git a/internal/tui/execution_view.go b/internal/tui/execution_view.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..1d6842ab4a2a768b2cd8b47549ecd1e0f0240868\n--- /dev/null\n+++ b/internal/tui/execution_view.go\n@@ -0,0 +1,142 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/charmbracelet/lipgloss\"\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+)\n+\n+var timeNow = time.Now\n+\n+func RenderExecutionView(model Model) string {\n+\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"69\"))\n+\tlabelStyle := lipgloss.NewStyle().Bold(true)\n+\tmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"240\"))\n+\n+\tactive := findActiveRun(model.runData)\n+\n+\tvar b strings.Builder\n+\twriteSectionHeader(\u0026b, headerStyle, \"Active Run\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"No active runs.\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Task\", active.TaskID)\n+\t\tstatus := renderRunStatus(active.Status)\n+\t\tb.WriteString(labelStyle.Render(\"Status: \"))\n+\t\tb.WriteString(status)\n+\t\tb.WriteString(\"\\n\")\n+\t\twriteLabeledLine(\u0026b, labelStyle, \"Elapsed\", formatElapsed(active.StartedAt, active.CompletedAt))\n+\t\tif active.CompletedAt != nil {\n+\t\t\texitCode := \"-\"\n+\t\t\tif active.ExitCode != nil {\n+\t\t\t\texitCode = fmt.Sprintf(\"%d\", *active.ExitCode)\n+\t\t\t}\n+\t\t\twriteLabeledLine(\u0026b, labelStyle, \"Exit code\", exitCode)\n+\t\t}\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Log Output\")\n+\tif active == nil {\n+\t\tb.WriteString(mutedStyle.Render(\"(no logs)\"))\n+\t\tb.WriteString(\"\\n\\n\")\n+\t} else {\n+\t\twriteLogExcerpt(\u0026b, \"stdout\", active.Stdout, mutedStyle)\n+\t\twriteLogExcerpt(\u0026b, \"stderr\", active.Stderr, mutedStyle)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+\n+\twriteSectionHeader(\u0026b, headerStyle, \"Task Summary\")\n+\treadyCount := len(execution.ReadyTasks(model.plan))\n+\tblockedCount := blockedCount(model.plan)\n+\twriteLabeledLine(\u0026b, labelStyle, \"Ready\", fmt.Sprintf(\"%d\", readyCount))\n+\twriteLabeledLine(\u0026b, labelStyle, \"Blocked\", fmt.Sprintf(\"%d\", blockedCount))\n+\n+\tcontent := strings.TrimRight(b.String(), \"\\n\")\n+\treturn applyViewport(model, content)\n+}\n+\n+func findActiveRun(runData map[string]execution.RunRecord) *execution.RunRecord {\n+\tif len(runData) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar selected *execution.RunRecord\n+\tfor _, record := range runData {\n+\t\tif record.Status != execution.RunStatusRunning \u0026\u0026 record.Status != execution.RunStatusWaitingUser {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif selected == nil || record.StartedAt.After(selected.StartedAt) {\n+\t\t\tcopy := record\n+\t\t\tselected = \u0026copy\n+\t\t}\n+\t}\n+\treturn selected\n+}\n+\n+func renderRunStatus(status execution.RunStatus) string {\n+\tstyle := lipgloss.NewStyle()\n+\tswitch status {\n+\tcase execution.RunStatusSuccess:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"42\"))\n+\tcase execution.RunStatusFailed:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"196\"))\n+\tcase execution.RunStatusWaitingUser:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"214\"))\n+\tcase execution.RunStatusRunning:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"39\"))\n+\tdefault:\n+\t\tstyle = style.Foreground(lipgloss.Color(\"240\"))\n+\t}\n+\treturn style.Render(string(status))\n+}\n+\n+func formatElapsed(startedAt time.Time, completedAt *time.Time) string {\n+\tend := timeNow()\n+\tif completedAt != nil {\n+\t\tend = *completedAt\n+\t}\n+\tif end.Before(startedAt) {\n+\t\tend = startedAt\n+\t}\n+\tduration := end.Sub(startedAt).Truncate(time.Second)\n+\ttotalSeconds := int(duration.Seconds())\n+\thours := totalSeconds / 3600\n+\tminutes := (totalSeconds % 3600) / 60\n+\tseconds := totalSeconds % 60\n+\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n+}\n+\n+func writeLogExcerpt(b *strings.Builder, label string, content string, mutedStyle lipgloss.Style) {\n+\tlines := tailLines(content, 20)\n+\tb.WriteString(strings.ToUpper(label))\n+\tb.WriteString(\":\\n\")\n+\tif len(lines) == 0 {\n+\t\tb.WriteString(mutedStyle.Render(\"(empty)\"))\n+\t\tb.WriteString(\"\\n\")\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tb.WriteString(line)\n+\t\tb.WriteString(\"\\n\")\n+\t}\n+}\n+\n+func tailLines(content string, limit int) []string {\n+\tif limit \u003c= 0 {\n+\t\treturn nil\n+\t}\n+\tnormalized := strings.ReplaceAll(content, \"\\r\\n\", \"\\n\")\n+\tnormalized = strings.TrimRight(normalized, \"\\n\")\n+\tif strings.TrimSpace(normalized) == \"\" {\n+\t\treturn nil\n+\t}\n+\tlines := strings.Split(normalized, \"\\n\")\n+\tif len(lines) \u003e limit {\n+\t\tlines = lines[len(lines)-limit:]\n+\t}\n+\treturn lines\n+}\ndiff --git a/internal/tui/execution_view_test.go b/internal/tui/execution_view_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9e26634948ae1f21e338159abab17a743da0693\n--- /dev/null\n+++ b/internal/tui/execution_view_test.go\n@@ -0,0 +1,94 @@\n+package tui\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/execution\"\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestRenderExecutionViewActiveRun(t *testing.T) {\n+\tnow := time.Date(2026, 1, 29, 12, 0, 0, 0, time.UTC)\n+\toriginalTimeNow := timeNow\n+\ttimeNow = func() time.Time { return now }\n+\tt.Cleanup(func() { timeNow = originalTimeNow })\n+\n+\tg := plan.WorkGraph{\n+\t\tSchemaVersion: plan.SchemaVersion,\n+\t\tItems: map[string]plan.WorkItem{\n+\t\t\t\"task-1\": {\n+\t\t\t\tID:        \"task-1\",\n+\t\t\t\tTitle:     \"Ready task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t\t\"task-2\": {\n+\t\t\t\tID:        \"task-2\",\n+\t\t\t\tTitle:     \"Blocked task\",\n+\t\t\t\tStatus:    plan.StatusTodo,\n+\t\t\t\tDeps:      []string{\"task-1\"},\n+\t\t\t\tCreatedAt: now,\n+\t\t\t\tUpdatedAt: now,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tstdout := makeLines(\"out\", 25)\n+\tstderr := makeLines(\"err\", 5)\n+\tstarted := now.Add(-90 * time.Second)\n+\trunData := map[string]execution.RunRecord{\n+\t\t\"task-1\": {\n+\t\t\tID:        \"run-1\",\n+\t\t\tTaskID:    \"task-1\",\n+\t\t\tStartedAt: started,\n+\t\t\tStatus:    execution.RunStatusRunning,\n+\t\t\tStdout:    stdout,\n+\t\t\tStderr:    stderr,\n+\t\t},\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:    g,\n+\t\trunData: runData,\n+\t}\n+\n+\tout := RenderExecutionView(model)\n+\n+\tassertContains(t, out, \"Active Run\")\n+\tassertContains(t, out, \"Task: task-1\")\n+\tassertContains(t, out, \"Elapsed: 00:01:30\")\n+\tassertContains(t, out, \"Log Output\")\n+\tassertContains(t, out, \"STDOUT:\")\n+\tassertContains(t, out, \"out-25\")\n+\tif strings.Contains(out, \"out-01\") {\n+\t\tt.Fatalf(\"expected stdout tail to exclude out-01, got %q\", out)\n+\t}\n+\tassertContains(t, out, \"STDERR:\")\n+\tassertContains(t, out, \"err-05\")\n+\tassertContains(t, out, \"Task Summary\")\n+\tassertContains(t, out, \"Ready: 1\")\n+\tassertContains(t, out, \"Blocked: 1\")\n+}\n+\n+func TestRenderExecutionViewEmptyState(t *testing.T) {\n+\tmodel := Model{}\n+\tout := RenderExecutionView(model)\n+\tassertContains(t, out, \"No active runs.\")\n+\tassertContains(t, out, \"(no logs)\")\n+}\n+\n+func makeLines(prefix string, count int) string {\n+\tlines := make([]string, 0, count)\n+\tfor i := 1; i \u003c= count; i++ {\n+\t\tlines = append(lines, fmtLine(prefix, i))\n+\t}\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n+func fmtLine(prefix string, index int) string {\n+\treturn fmt.Sprintf(\"%s-%02d\", prefix, index)\n+}\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex 20bc4fc94f6e42511f41968a1c5721faf59d9761..c844a9f0678de356323750c85c5663c9e1d5b5a1\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -26,10 +26,15 @@\n \tactionInProgress bool\n \tactionName       string\n \tspinnerIndex     int\n+\trunData          map[string]execution.RunRecord\n }\n \n func NewModel(g plan.WorkGraph) Model {\n-\tm := Model{plan: g, actionMode: ActionModeNone}\n+\tm := Model{\n+\t\tplan:       g,\n+\t\tactionMode: ActionModeNone,\n+\t\trunData:    map[string]execution.RunRecord{},\n+\t}\n \tfor id := range g.Items {\n \t\tm.selectedID = id\n \t\tbreak\n\ntokens used\n77,320\n",
  "context": {
    "schemaVersion": 1,
    "task": {
      "id": "execution-view-render",
      "title": "Render execution dashboard view",
      "description": "Implement the rendering logic for the execution dashboard including run status, elapsed time, log excerpts, and task counts.",
      "acceptanceCriteria": [
        "Renders current run status section with task ID and status",
        "Shows formatted elapsed time (HH:MM:SS)",
        "Displays exit code if completed",
        "Shows log excerpt in scrollable area",
        "Displays ready/blocked task counts",
        "Empty state when no active runs",
        "Uses lipgloss for styling"
      ],
      "prompt": "Create internal/tui/execution_view.go with RenderExecutionView(model Model) string function. Access model.runData (populated by run-data-loader). Format sections: Active Run (task ID, status with color, elapsed time, exit code), Log Output (last 20 lines of stdout/stderr), Task Summary (X ready, Y blocked using execution.ReadyTasks and plan.UnmetDeps counts). Handle empty state gracefully. Use lipgloss for section headers and status colors."
    },
    "projectSnapshot": "# Product Specification: AI-Orchestrated CLI for Structured, Dependency-Aware Software Delivery\n\n## 1. Product Summary\n\nA terminal-native product that functions as the authoritative “master memory” and execution control plane for building software with AI coding agents (e.g., Claude Code, Codex, or other agent runtimes). The product externalizes project planning, state, decisions, and execution history into durable, inspectable artifacts, enabling short-lived, task-scoped agent sessions to reliably deliver work without needing long-lived conversational context.\n\nThe core workflow is:\n\n1. define a structured feature/task graph where every node has an associated agent prompt,\n2. compute what work is actionable based on dependencies and current status,\n3. select and queue work from the terminal,\n4. run agents against specific tasks with a consistent “context pack” (project snapshot + task prompt + relevant prior outputs),\n5. continuously track and surface progress in a live CLI dashboard,\n6. allow agents to request clarification/confirmation from the user with prominent alerts and inline responses,\n7. continuously maintain a concise “current state of the app” summary for new agent runs.\n\nThe product is designed to make AI work reliable, repeatable, and coordinated across many agent invocations by treating memory and task structure as first-class artifacts.\n\n---\n\n## 2. Target Users\n\n### Primary\n\n* Solo developers and senior engineers building non-trivial systems who want:\n\n  * reliable continuity across many agent runs\n  * stronger control over what agents do\n  * a structured plan that stays synchronized with code reality\n\n### Secondary\n\n* Small teams coordinating AI-assisted work through a shared repo-local plan, where task structure and “project memory” are versioned artifacts.\n\n---\n\n## 3. Problems Solved\n\n1. **Loss of continuity across agent runs**\n\n   * Agents forget past context, causing rework and regressions.\n\n2. **Unreliable execution when context is oversized**\n\n   * Overloaded prompts reduce quality and increase drift.\n\n3. **Poor coordination between tasks**\n\n   * Flat lists and ad-hoc prompting don’t enforce ordering, dependencies, or readiness.\n\n4. **Weak visibility into what AI is doing**\n\n   * Users lack a clear real-time view of status, progress, logs, and time in state.\n\n5. **High friction when agents need human input**\n\n   * Agents often need confirmation or clarification; existing tooling doesn’t integrate user responses cleanly.\n\n6. **Parallelization without guardrails**\n\n   * Running multiple tasks concurrently can cause collisions and inconsistent outcomes.\n\n---\n\n## 4. Core Product Concepts\n\n### 4.1 Project “Master Memory”\n\nThe product maintains a durable, human-readable representation of project state that persists across sessions and can be used to seed new agent runs. This “master memory” is made of:\n\n* **Structured work graph**: the set of tasks/features, their hierarchy, and dependencies.\n* **Project snapshot**: a periodically refreshed summary of “current state of the app.”\n* **Decision log**: a record of key decisions and rationale to prevent re-deciding.\n\nThese artifacts are the source of truth for intent and context, reducing reliance on any single agent’s context window.\n\n### 4.2 Structured Work Graph (Feature Tree + Dependency DAG)\n\nWork is represented as a hierarchical tree for human comprehension and an explicit dependency graph for execution correctness.\n\n* **Tree**: features → subfeatures → tasks\n* **DAG**: prerequisite relationships that determine readiness and build order\n\nEach node in the graph is a first-class work item with metadata and a canonical agent prompt.\n\n### 4.3 Stateless, Task-Scoped Agent Execution\n\nAgents are treated as disposable workers:\n\n* each run has a bounded scope (a single task node)\n* receives a standardized context pack\n* produces outputs that are recorded and linked to the task\n* updates task status and project memory as appropriate\n\nThis reduces drift and makes the system resilient to agent restarts or failures.\n\n### 4.4 Context Pack\n\nA context pack is the curated set of information provided to an agent for a given task. It is designed to:\n\n* be sufficient for task completion\n* remain compact and consistent\n* be inspectable for auditability\n\nThe context pack is composed of:\n\n* the task’s canonical prompt\n* the latest project snapshot\n* relevant decision log entries\n* outputs/artifacts from prerequisite tasks\n* optionally task-scoped notes and constraints\n\nThe product surfaces context-pack size and composition (including token estimates where possible) to help users manage context window usage.\n\n---\n\n## 5. Product Capabilities\n\n## 5.1 Work Definition and Management\n\n### Work Items\n\nEach work item (at every level—feature, subfeature, task) includes:\n\n* **Identifier**: stable, unique ID\n* **Title**: concise summary\n* **Description**: context and acceptance criteria\n* **Canonical prompt**: the instruction sent to the agent for that node\n* **Hierarchy**: parent/children relationships\n* **Dependencies**: prerequisite node IDs (graph edges)\n* **Status**: current lifecycle state (see below)\n* **Artifacts**: links/refs to outputs (diffs, branches, files, PRs, notes)\n* **History**: timestamps and status transitions\n* **Tags/metadata**: optional categorization, priority, ownership, estimates\n\n### Status Model\n\nThe product supports clear statuses that reflect both planning and execution reality. At minimum:\n\n* `todo`: defined but not yet actionable or started\n* `ready`: all dependencies satisfied; actionable\n* `queued`: selected for execution but not yet started\n* `in_progress`: actively being worked on by an agent or user\n* `waiting_user`: blocked on user clarification/confirmation\n* `blocked`: cannot proceed due to unmet dependency or external constraint\n* `done`: completed\n* `failed`: execution ended unsuccessfully\n* `skipped`: intentionally not done\n\nThe product must:\n\n* compute readiness based on dependency completion\n* explain why items are blocked\n* optionally derive parent status from children (e.g., feature is “in progress” if any child is in progress)\n\n### Dependency Awareness\n\nThe product:\n\n* validates the dependency graph (e.g., rejects cycles)\n* computes which tasks are actionable (“ready”) based on completion of prerequisites\n* allows users to view dependency chains and block reasons\n* supports selectively showing/hiding tasks based on dependency state (e.g., only show ready tasks)\n\n---\n\n## 5.2 Terminal Task Selection and Navigation\n\n### Fast Selection\n\nThe product provides an interactive terminal selection interface that lets users:\n\n* filter by readiness (default: show “ready”)\n* toggle visibility of blocked/done items\n* search by title/ID/tags\n* quickly open a task to view details or run it\n\n### Task Detail View\n\nUsers can view:\n\n* full description and acceptance criteria\n* canonical prompt\n* dependencies and readiness explanation\n* execution history and artifacts\n* current context pack composition (snapshot version, included decision entries, prerequisite outputs, estimated token usage)\n\n---\n\n## 5.3 Queueing and Execution\n\n### Task Queue\n\nUsers can build a queue of tasks to execute. The product supports:\n\n* enqueue/dequeue/reorder\n* queue views filtered by readiness\n* execution state per queued item\n\n### Execution Semantics\n\nThe product supports:\n\n* executing a single selected task\n* executing queued tasks in order, constrained by readiness\n* optionally executing multiple independent tasks concurrently (when safe and permitted by dependency constraints)\n\nExecution outcomes are recorded as task artifacts and in run history.\n\n---\n\n## 5.4 Agent Integration as a Pluggable Runtime (Conceptual)\n\nThe product can invoke one or more agent runtimes to execute tasks. Regardless of the underlying agent provider, the product treats agents uniformly:\n\nA task run results in:\n\n* a run record with lifecycle state\n* a log/event stream\n* produced artifacts (code changes, patch/diff, notes, generated docs)\n* optional structured outputs (e.g., “created files”, “tests run”, “questions asked”)\n* status updates on the associated task\n\nThe product does not require persistent agent sessions; instead it optimizes for consistent, repeatable task runs.\n\n---\n\n## 5.5 Real-Time CLI Dashboard\n\n### Purpose\n\nA live terminal dashboard provides immediate visibility into what is happening now and what is blocked, waiting, or completed.\n\n### Dashboard Views\n\nThe dashboard includes:\n\n1. **Active workers / runs**\n\n   * which task each worker is processing\n   * current run state\n   * elapsed time in state\n   * last activity timestamp\n2. **Selected task/run details**\n\n   * task metadata, dependencies, artifacts\n   * recent status transitions\n   * context pack summary\n\n     * snapshot version identifier\n     * included decision entries count\n     * included prerequisite outputs count\n     * estimated context size and, where available, actual usage\n3. **Event/log stream**\n\n   * streaming view of events (system/agent/git/tests-style categories conceptually)\n   * ability to filter the stream and inspect recent history\n\n### Run Lifecycle States (Dashboard-Oriented)\n\nThe dashboard surfaces run-specific states such as:\n\n* `queued`\n* `building_context`\n* `running_agent`\n* `waiting_user`\n* `applying_changes`\n* `verifying`\n* `done`\n* `failed`\n* `canceled`\n\nEach run state change is time-stamped and reflected in elapsed-time metrics.\n\n---\n\n## 5.6 Human-in-the-Loop Clarification \u0026 Confirmation\n\n### Agent-to-User Questions\n\nAgents can request:\n\n* **clarification** (missing info)\n* **confirmation** (permission to proceed)\n* **decision** (choose among options)\n\nThese requests must:\n\n* transition the run into a `waiting_user` state\n* generate a prominent alert in the CLI\n* be answered directly in the CLI\n* resume execution using the user’s response\n* be recorded permanently in run history (and optionally in the project decision log)\n\n### Alerting\n\nWhen user input is requested, the product provides:\n\n* prominent visual alerting in the dashboard (highlight/badge/attention state)\n* optional audible alert\n* a clear “unread questions” indicator\n* a queue of pending questions across runs\n\n### Response Experience\n\nUsers can:\n\n* answer inline in the dashboard\n* choose from options when provided\n* attach a note explaining rationale\n* optionally mark the response as a durable project decision\n\nAll Q/A is associated with a run and task for traceability.\n\n---\n\n## 5.7 Continuous Project Snapshot (“Current State of the App”)\n\n### Purpose\n\nMaintain a compact, regularly refreshed representation of current application state that can be used as the first thing included in new agent contexts.\n\n### Snapshot Content (What it captures)\n\nAt minimum:\n\n* implemented features and current behavior\n* current architecture overview (major modules and responsibilities)\n* key interfaces/contracts and invariants\n* known limitations and outstanding issues\n* conventions (naming, patterns, guidelines that agents should follow)\n* pointers to where key code lives\n\n### Snapshot Requirements\n\n* **Bounded**: stays within a target size and format so it is usable in an agent context window\n* **Trustworthy**: updated frequently enough to remain accurate\n* **Inspectable**: users can read it directly\n* **Versioned**: each snapshot has an identifier (timestamp/hash) so task runs can reference exactly what they used\n\n### Relationship to Task Runs\n\nEach task run references:\n\n* which snapshot version it used\n* which decisions/notes were included\n* optionally which prerequisite outputs were included\n\nThis supports reproducibility and debugging.\n\n---\n\n## 5.8 Decision Log\n\n### Purpose\n\nPrevent repeated re-litigation of foundational choices by capturing “what we decided and why.”\n\n### Decision Entries\n\nEach decision includes:\n\n* decision statement\n* rationale / tradeoffs\n* scope (what it affects)\n* timestamp and origin (user vs agent-assisted)\n* optionally links to tasks/runs that produced it\n\nThe product enables promoting a clarification/confirmation answer into a durable decision entry.\n\n---\n\n## 6. End-to-End User Journeys\n\n## 6.1 From Idea to Executable Plan\n\n1. User defines a high-level goal.\n2. The product holds a structured feature tree with tasks and subtasks.\n3. Every node has a canonical prompt so execution is possible at any level.\n4. Dependencies are defined so readiness can be computed.\n\nOutcome: a durable, navigable work graph exists, and “ready tasks” are identifiable.\n\n## 6.2 Selecting and Running Work\n\n1. User opens the task picker and sees only “ready” tasks by default.\n2. User selects a task and starts execution.\n3. The product constructs a context pack (task prompt + project snapshot + relevant history).\n4. A run begins and appears in the dashboard.\n\nOutcome: user can see exactly what is being worked on and how long it has been running.\n\n## 6.3 Agent Requires Input\n\n1. During execution, the agent asks a clarification/confirmation question.\n2. The dashboard prominently alerts the user and shows the question.\n3. User answers inline; optionally marks it as a decision.\n4. Execution resumes with that response included in context.\n\nOutcome: the agent is unblocked quickly, and the interaction is recorded.\n\n## 6.4 Queueing and Ongoing Progress\n\n1. User enqueues multiple tasks.\n2. The product executes tasks when they become ready.\n3. The dashboard shows:\n\n   * which tasks are running\n   * which are queued but blocked\n   * which completed and produced artifacts\n\nOutcome: the user can run structured, dependency-aware work sessions with high visibility.\n\n---\n\n## 7. Product Outputs and Artifacts\n\nThe product produces durable artifacts that users can inspect and version:\n\n* work graph definitions (features/tasks/prompts/deps/status)\n* run records (what ran, when, final state)\n* event/log history per run\n* question/answer history per run\n* project snapshot versions\n* decision log entries\n* links to produced artifacts (patches/diffs/docs)\n\nThese artifacts enable:\n\n* reproducibility (“what context did this run use?”)\n* debugging (“why did it fail?”)\n* continuity (“what’s the current state?”)\n* onboarding (“how does the system work?”)\n\n---\n\n## 8. Non-Functional Requirements (What the product must feel like)\n\n### 8.1 Trust and Inspectability\n\n* Users must be able to see:\n\n  * what the agent was asked to do\n  * what context it was given\n  * what it changed/produced\n  * why a task is blocked or waiting\n\n### 8.2 Low Friction\n\n* Fast selection and navigation in the terminal\n* Minimal ceremony to run the next task\n* Clear, immediate signaling when the user is needed\n\n### 8.3 Resilience\n\n* Runs, status, and memory persist across restarts\n* The dashboard can reconnect and reconstruct the current state\n* Failures leave clear traces rather than silent corruption\n\n### 8.4 Boundedness and Drift Control\n\n* Project snapshot and prompts must be bounded and structured so agent runs remain reliable.\n* The system should emphasize stable “canonical prompts” and durable project memory over conversational accumulation.\n\n---\n\n## 9. Scope Boundaries\n\n### In-scope\n\n* structured work graph with prompts and dependencies\n* readiness computation and filtered selection\n* task queueing and execution tracking\n* real-time dashboard\n* clarification/confirmation question flow with alerting + inline responses\n* continuous project snapshot and decision log\n\n### Explicitly out of scope (for this spec)\n\n* specific implementation details (tech stack, storage format, process model)\n* specific agent provider features or APIs\n* detailed merge strategies, CI integration, or repository governance\n* advanced multi-user concurrency controls (beyond shared artifacts)\n\n---\n\n## 10. Success Criteria (Product-Level)\n\nA user should be able to:\n\n* maintain a durable, structured plan where every task is executable via an associated prompt\n* see only actionable work by default, based on explicit dependencies\n* run tasks with AI agents without re-explaining the project each time\n* recover instantly from agent restarts because memory is externalized\n* monitor active work in a live dashboard with clear run states and elapsed time\n* respond to agent questions promptly via CLI alerts and inline answers\n* onboard a new agent run with a reliable project snapshot that reduces drift and repeated questions",
    "systemPrompt": "You are authorized to run non-destructive commands and edit files needed to complete the task. Do not ask for confirmation. Avoid destructive operations (e.g., deleting unrelated files, wiping directories, resetting git history, or modifying system files)."
  }
}
