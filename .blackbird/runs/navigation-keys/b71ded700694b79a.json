{
  "id": "b71ded700694b79a",
  "taskId": "navigation-keys",
  "provider": "codex",
  "startedAt": "2026-01-29T01:48:59.181697Z",
  "completedAt": "2026-01-29T01:52:40.453222Z",
  "status": "success",
  "exitCode": 0,
  "stdout": "Added keyboard navigation in the TUI model: tree movement (arrows/j/k, home/end), expand/collapse (enter/space), pane toggle (tab), filter cycling (f), and detail paging (pgup/pgdown). This includes new visible-item traversal helpers to keep selection aligned with the rendered tree order and filter mode, plus selection snapping when filters or collapse hide the current item. Detail pane paging now uses a stored offset that’s clamped in `internal/tui/detail_view.go`. Added tests covering visible navigation and blocked-filter behavior.\n\nTests\n- `go test ./internal/tui/...` (failed: Go build cache permission error: `operation not permitted`)\n\nFiles touched\n- `internal/tui/model.go`\n- `internal/tui/detail_view.go`\n- `internal/tui/model_test.go`\n- `AGENT_LOG.md`\n\nSuggestions\n1) Re-run `go test ./internal/tui/...` in an environment where the Go build cache is writable.  \n2) Verify key handling in the TUI once the pane layout uses `activePane` to visually indicate focus.\n",
  "stderr": "Reading prompt from stdin...\nOpenAI Codex v0.87.0 (research preview)\n--------\nworkdir: /Users/jackbonatakis/repos/blackbird\nmodel: gpt-5.2-codex\nprovider: openai\napproval: never\nsandbox: workspace-write [workdir, /tmp, $TMPDIR]\nreasoning effort: none\nreasoning summaries: auto\nsession id: 019c0770-7fc9-7a70-b571-5dbb8050dc68\n--------\nuser\n{\"schemaVersion\":1,\"task\":{\"id\":\"navigation-keys\",\"title\":\"Implement keyboard navigation logic\",\"description\":\"Handle all keyboard inputs for navigating the tree (up/down), expanding/collapsing items (enter/space), switching panes (tab), filtering (f), and scrolling detail pane.\",\"acceptanceCriteria\":[\"Up/down arrows move selection in tree\",\"Enter or space expands/collapses parent items\",\"Tab switches focus between tree and detail panes\",\"f key cycles through filter modes (all/ready/blocked)\",\"j/k keys also work for vim-style navigation\",\"Page up/down scrolls detail pane\",\"Home/end keys jump to first/last item\"],\"prompt\":\"Update internal/tui/model.go Update() method to handle tea.KeyMsg. Implement: arrow up/down to move selection through visible items in tree order (respecting collapsed state), enter/space to toggle expanded state for parents, tab to toggle activePane between 'tree' and 'detail', f to cycle filterMode, j/k as aliases for up/down, page up/down for detail scrolling. Update selectedID and expandedItems map accordingly. Add helper methods: nextVisibleItem(), prevVisibleItem(), isParent().\"},\"dependencies\":[{\"id\":\"tree-view\",\"title\":\"Build hierarchical plan tree view\",\"status\":\"done\"},{\"id\":\"detail-view\",\"title\":\"Build item detail pane view\",\"status\":\"done\"}],\"projectSnapshot\":\"# Product Specification: AI-Orchestrated CLI for Structured, Dependency-Aware Software Delivery\\n\\n## 1. Product Summary\\n\\nA terminal-native product that functions as the authoritative “master memory” and execution control plane for building software with AI coding agents (e.g., Claude Code, Codex, or other agent runtimes). The product externalizes project planning, state, decisions, and execution history into durable, inspectable artifacts, enabling short-lived, task-scoped agent sessions to reliably deliver work without needing long-lived conversational context.\\n\\nThe core workflow is:\\n\\n1. define a structured feature/task graph where every node has an associated agent prompt,\\n2. compute what work is actionable based on dependencies and current status,\\n3. select and queue work from the terminal,\\n4. run agents against specific tasks with a consistent “context pack” (project snapshot + task prompt + relevant prior outputs),\\n5. continuously track and surface progress in a live CLI dashboard,\\n6. allow agents to request clarification/confirmation from the user with prominent alerts and inline responses,\\n7. continuously maintain a concise “current state of the app” summary for new agent runs.\\n\\nThe product is designed to make AI work reliable, repeatable, and coordinated across many agent invocations by treating memory and task structure as first-class artifacts.\\n\\n---\\n\\n## 2. Target Users\\n\\n### Primary\\n\\n* Solo developers and senior engineers building non-trivial systems who want:\\n\\n  * reliable continuity across many agent runs\\n  * stronger control over what agents do\\n  * a structured plan that stays synchronized with code reality\\n\\n### Secondary\\n\\n* Small teams coordinating AI-assisted work through a shared repo-local plan, where task structure and “project memory” are versioned artifacts.\\n\\n---\\n\\n## 3. Problems Solved\\n\\n1. **Loss of continuity across agent runs**\\n\\n   * Agents forget past context, causing rework and regressions.\\n\\n2. **Unreliable execution when context is oversized**\\n\\n   * Overloaded prompts reduce quality and increase drift.\\n\\n3. **Poor coordination between tasks**\\n\\n   * Flat lists and ad-hoc prompting don’t enforce ordering, dependencies, or readiness.\\n\\n4. **Weak visibility into what AI is doing**\\n\\n   * Users lack a clear real-time view of status, progress, logs, and time in state.\\n\\n5. **High friction when agents need human input**\\n\\n   * Agents often need confirmation or clarification; existing tooling doesn’t integrate user responses cleanly.\\n\\n6. **Parallelization without guardrails**\\n\\n   * Running multiple tasks concurrently can cause collisions and inconsistent outcomes.\\n\\n---\\n\\n## 4. Core Product Concepts\\n\\n### 4.1 Project “Master Memory”\\n\\nThe product maintains a durable, human-readable representation of project state that persists across sessions and can be used to seed new agent runs. This “master memory” is made of:\\n\\n* **Structured work graph**: the set of tasks/features, their hierarchy, and dependencies.\\n* **Project snapshot**: a periodically refreshed summary of “current state of the app.”\\n* **Decision log**: a record of key decisions and rationale to prevent re-deciding.\\n\\nThese artifacts are the source of truth for intent and context, reducing reliance on any single agent’s context window.\\n\\n### 4.2 Structured Work Graph (Feature Tree + Dependency DAG)\\n\\nWork is represented as a hierarchical tree for human comprehension and an explicit dependency graph for execution correctness.\\n\\n* **Tree**: features → subfeatures → tasks\\n* **DAG**: prerequisite relationships that determine readiness and build order\\n\\nEach node in the graph is a first-class work item with metadata and a canonical agent prompt.\\n\\n### 4.3 Stateless, Task-Scoped Agent Execution\\n\\nAgents are treated as disposable workers:\\n\\n* each run has a bounded scope (a single task node)\\n* receives a standardized context pack\\n* produces outputs that are recorded and linked to the task\\n* updates task status and project memory as appropriate\\n\\nThis reduces drift and makes the system resilient to agent restarts or failures.\\n\\n### 4.4 Context Pack\\n\\nA context pack is the curated set of information provided to an agent for a given task. It is designed to:\\n\\n* be sufficient for task completion\\n* remain compact and consistent\\n* be inspectable for auditability\\n\\nThe context pack is composed of:\\n\\n* the task’s canonical prompt\\n* the latest project snapshot\\n* relevant decision log entries\\n* outputs/artifacts from prerequisite tasks\\n* optionally task-scoped notes and constraints\\n\\nThe product surfaces context-pack size and composition (including token estimates where possible) to help users manage context window usage.\\n\\n---\\n\\n## 5. Product Capabilities\\n\\n## 5.1 Work Definition and Management\\n\\n### Work Items\\n\\nEach work item (at every level—feature, subfeature, task) includes:\\n\\n* **Identifier**: stable, unique ID\\n* **Title**: concise summary\\n* **Description**: context and acceptance criteria\\n* **Canonical prompt**: the instruction sent to the agent for that node\\n* **Hierarchy**: parent/children relationships\\n* **Dependencies**: prerequisite node IDs (graph edges)\\n* **Status**: current lifecycle state (see below)\\n* **Artifacts**: links/refs to outputs (diffs, branches, files, PRs, notes)\\n* **History**: timestamps and status transitions\\n* **Tags/metadata**: optional categorization, priority, ownership, estimates\\n\\n### Status Model\\n\\nThe product supports clear statuses that reflect both planning and execution reality. At minimum:\\n\\n* `todo`: defined but not yet actionable or started\\n* `ready`: all dependencies satisfied; actionable\\n* `queued`: selected for execution but not yet started\\n* `in_progress`: actively being worked on by an agent or user\\n* `waiting_user`: blocked on user clarification/confirmation\\n* `blocked`: cannot proceed due to unmet dependency or external constraint\\n* `done`: completed\\n* `failed`: execution ended unsuccessfully\\n* `skipped`: intentionally not done\\n\\nThe product must:\\n\\n* compute readiness based on dependency completion\\n* explain why items are blocked\\n* optionally derive parent status from children (e.g., feature is “in progress” if any child is in progress)\\n\\n### Dependency Awareness\\n\\nThe product:\\n\\n* validates the dependency graph (e.g., rejects cycles)\\n* computes which tasks are actionable (“ready”) based on completion of prerequisites\\n* allows users to view dependency chains and block reasons\\n* supports selectively showing/hiding tasks based on dependency state (e.g., only show ready tasks)\\n\\n---\\n\\n## 5.2 Terminal Task Selection and Navigation\\n\\n### Fast Selection\\n\\nThe product provides an interactive terminal selection interface that lets users:\\n\\n* filter by readiness (default: show “ready”)\\n* toggle visibility of blocked/done items\\n* search by title/ID/tags\\n* quickly open a task to view details or run it\\n\\n### Task Detail View\\n\\nUsers can view:\\n\\n* full description and acceptance criteria\\n* canonical prompt\\n* dependencies and readiness explanation\\n* execution history and artifacts\\n* current context pack composition (snapshot version, included decision entries, prerequisite outputs, estimated token usage)\\n\\n---\\n\\n## 5.3 Queueing and Execution\\n\\n### Task Queue\\n\\nUsers can build a queue of tasks to execute. The product supports:\\n\\n* enqueue/dequeue/reorder\\n* queue views filtered by readiness\\n* execution state per queued item\\n\\n### Execution Semantics\\n\\nThe product supports:\\n\\n* executing a single selected task\\n* executing queued tasks in order, constrained by readiness\\n* optionally executing multiple independent tasks concurrently (when safe and permitted by dependency constraints)\\n\\nExecution outcomes are recorded as task artifacts and in run history.\\n\\n---\\n\\n## 5.4 Agent Integration as a Pluggable Runtime (Conceptual)\\n\\nThe product can invoke one or more agent runtimes to execute tasks. Regardless of the underlying agent provider, the product treats agents uniformly:\\n\\nA task run results in:\\n\\n* a run record with lifecycle state\\n* a log/event stream\\n* produced artifacts (code changes, patch/diff, notes, generated docs)\\n* optional structured outputs (e.g., “created files”, “tests run”, “questions asked”)\\n* status updates on the associated task\\n\\nThe product does not require persistent agent sessions; instead it optimizes for consistent, repeatable task runs.\\n\\n---\\n\\n## 5.5 Real-Time CLI Dashboard\\n\\n### Purpose\\n\\nA live terminal dashboard provides immediate visibility into what is happening now and what is blocked, waiting, or completed.\\n\\n### Dashboard Views\\n\\nThe dashboard includes:\\n\\n1. **Active workers / runs**\\n\\n   * which task each worker is processing\\n   * current run state\\n   * elapsed time in state\\n   * last activity timestamp\\n2. **Selected task/run details**\\n\\n   * task metadata, dependencies, artifacts\\n   * recent status transitions\\n   * context pack summary\\n\\n     * snapshot version identifier\\n     * included decision entries count\\n     * included prerequisite outputs count\\n     * estimated context size and, where available, actual usage\\n3. **Event/log stream**\\n\\n   * streaming view of events (system/agent/git/tests-style categories conceptually)\\n   * ability to filter the stream and inspect recent history\\n\\n### Run Lifecycle States (Dashboard-Oriented)\\n\\nThe dashboard surfaces run-specific states such as:\\n\\n* `queued`\\n* `building_context`\\n* `running_agent`\\n* `waiting_user`\\n* `applying_changes`\\n* `verifying`\\n* `done`\\n* `failed`\\n* `canceled`\\n\\nEach run state change is time-stamped and reflected in elapsed-time metrics.\\n\\n---\\n\\n## 5.6 Human-in-the-Loop Clarification \\u0026 Confirmation\\n\\n### Agent-to-User Questions\\n\\nAgents can request:\\n\\n* **clarification** (missing info)\\n* **confirmation** (permission to proceed)\\n* **decision** (choose among options)\\n\\nThese requests must:\\n\\n* transition the run into a `waiting_user` state\\n* generate a prominent alert in the CLI\\n* be answered directly in the CLI\\n* resume execution using the user’s response\\n* be recorded permanently in run history (and optionally in the project decision log)\\n\\n### Alerting\\n\\nWhen user input is requested, the product provides:\\n\\n* prominent visual alerting in the dashboard (highlight/badge/attention state)\\n* optional audible alert\\n* a clear “unread questions” indicator\\n* a queue of pending questions across runs\\n\\n### Response Experience\\n\\nUsers can:\\n\\n* answer inline in the dashboard\\n* choose from options when provided\\n* attach a note explaining rationale\\n* optionally mark the response as a durable project decision\\n\\nAll Q/A is associated with a run and task for traceability.\\n\\n---\\n\\n## 5.7 Continuous Project Snapshot (“Current State of the App”)\\n\\n### Purpose\\n\\nMaintain a compact, regularly refreshed representation of current application state that can be used as the first thing included in new agent contexts.\\n\\n### Snapshot Content (What it captures)\\n\\nAt minimum:\\n\\n* implemented features and current behavior\\n* current architecture overview (major modules and responsibilities)\\n* key interfaces/contracts and invariants\\n* known limitations and outstanding issues\\n* conventions (naming, patterns, guidelines that agents should follow)\\n* pointers to where key code lives\\n\\n### Snapshot Requirements\\n\\n* **Bounded**: stays within a target size and format so it is usable in an agent context window\\n* **Trustworthy**: updated frequently enough to remain accurate\\n* **Inspectable**: users can read it directly\\n* **Versioned**: each snapshot has an identifier (timestamp/hash) so task runs can reference exactly what they used\\n\\n### Relationship to Task Runs\\n\\nEach task run references:\\n\\n* which snapshot version it used\\n* which decisions/notes were included\\n* optionally which prerequisite outputs were included\\n\\nThis supports reproducibility and debugging.\\n\\n---\\n\\n## 5.8 Decision Log\\n\\n### Purpose\\n\\nPrevent repeated re-litigation of foundational choices by capturing “what we decided and why.”\\n\\n### Decision Entries\\n\\nEach decision includes:\\n\\n* decision statement\\n* rationale / tradeoffs\\n* scope (what it affects)\\n* timestamp and origin (user vs agent-assisted)\\n* optionally links to tasks/runs that produced it\\n\\nThe product enables promoting a clarification/confirmation answer into a durable decision entry.\\n\\n---\\n\\n## 6. End-to-End User Journeys\\n\\n## 6.1 From Idea to Executable Plan\\n\\n1. User defines a high-level goal.\\n2. The product holds a structured feature tree with tasks and subtasks.\\n3. Every node has a canonical prompt so execution is possible at any level.\\n4. Dependencies are defined so readiness can be computed.\\n\\nOutcome: a durable, navigable work graph exists, and “ready tasks” are identifiable.\\n\\n## 6.2 Selecting and Running Work\\n\\n1. User opens the task picker and sees only “ready” tasks by default.\\n2. User selects a task and starts execution.\\n3. The product constructs a context pack (task prompt + project snapshot + relevant history).\\n4. A run begins and appears in the dashboard.\\n\\nOutcome: user can see exactly what is being worked on and how long it has been running.\\n\\n## 6.3 Agent Requires Input\\n\\n1. During execution, the agent asks a clarification/confirmation question.\\n2. The dashboard prominently alerts the user and shows the question.\\n3. User answers inline; optionally marks it as a decision.\\n4. Execution resumes with that response included in context.\\n\\nOutcome: the agent is unblocked quickly, and the interaction is recorded.\\n\\n## 6.4 Queueing and Ongoing Progress\\n\\n1. User enqueues multiple tasks.\\n2. The product executes tasks when they become ready.\\n3. The dashboard shows:\\n\\n   * which tasks are running\\n   * which are queued but blocked\\n   * which completed and produced artifacts\\n\\nOutcome: the user can run structured, dependency-aware work sessions with high visibility.\\n\\n---\\n\\n## 7. Product Outputs and Artifacts\\n\\nThe product produces durable artifacts that users can inspect and version:\\n\\n* work graph definitions (features/tasks/prompts/deps/status)\\n* run records (what ran, when, final state)\\n* event/log history per run\\n* question/answer history per run\\n* project snapshot versions\\n* decision log entries\\n* links to produced artifacts (patches/diffs/docs)\\n\\nThese artifacts enable:\\n\\n* reproducibility (“what context did this run use?”)\\n* debugging (“why did it fail?”)\\n* continuity (“what’s the current state?”)\\n* onboarding (“how does the system work?”)\\n\\n---\\n\\n## 8. Non-Functional Requirements (What the product must feel like)\\n\\n### 8.1 Trust and Inspectability\\n\\n* Users must be able to see:\\n\\n  * what the agent was asked to do\\n  * what context it was given\\n  * what it changed/produced\\n  * why a task is blocked or waiting\\n\\n### 8.2 Low Friction\\n\\n* Fast selection and navigation in the terminal\\n* Minimal ceremony to run the next task\\n* Clear, immediate signaling when the user is needed\\n\\n### 8.3 Resilience\\n\\n* Runs, status, and memory persist across restarts\\n* The dashboard can reconnect and reconstruct the current state\\n* Failures leave clear traces rather than silent corruption\\n\\n### 8.4 Boundedness and Drift Control\\n\\n* Project snapshot and prompts must be bounded and structured so agent runs remain reliable.\\n* The system should emphasize stable “canonical prompts” and durable project memory over conversational accumulation.\\n\\n---\\n\\n## 9. Scope Boundaries\\n\\n### In-scope\\n\\n* structured work graph with prompts and dependencies\\n* readiness computation and filtered selection\\n* task queueing and execution tracking\\n* real-time dashboard\\n* clarification/confirmation question flow with alerting + inline responses\\n* continuous project snapshot and decision log\\n\\n### Explicitly out of scope (for this spec)\\n\\n* specific implementation details (tech stack, storage format, process model)\\n* specific agent provider features or APIs\\n* detailed merge strategies, CI integration, or repository governance\\n* advanced multi-user concurrency controls (beyond shared artifacts)\\n\\n---\\n\\n## 10. Success Criteria (Product-Level)\\n\\nA user should be able to:\\n\\n* maintain a durable, structured plan where every task is executable via an associated prompt\\n* see only actionable work by default, based on explicit dependencies\\n* run tasks with AI agents without re-explaining the project each time\\n* recover instantly from agent restarts because memory is externalized\\n* monitor active work in a live dashboard with clear run states and elapsed time\\n* respond to agent questions promptly via CLI alerts and inline answers\\n* onboard a new agent run with a reliable project snapshot that reduces drift and repeated questions\",\"systemPrompt\":\"You are authorized to run non-destructive commands and edit files needed to complete the task. Do not ask for confirmation. Avoid destructive operations (e.g., deleting unrelated files, wiping directories, resetting git history, or modifying system files).\"}\nmcp startup: no servers\n\nthinking\n**Planning log inspection**\n\nI'm preparing to read the AGENT_LOG and OVERVIEW files using ripgrep to gather instructions and context for the next steps.\nexec\n/bin/zsh -lc ls in /Users/jackbonatakis/repos/blackbird succeeded in 84ms:\nAGENT_LOG.md\nAGENTS.md\nblackbird.plan.json\ncmd\ngo.mod\ninternal\nOVERVIEW.md\nREADME.md\nspecs\nexec\n/bin/zsh -lc 'cat OVERVIEW.md' in /Users/jackbonatakis/repos/blackbird succeeded in 85ms:\n# Product Specification: AI-Orchestrated CLI for Structured, Dependency-Aware Software Delivery\n\n## 1. Product Summary\n\nA terminal-native product that functions as the authoritative “master memory” and execution control plane for building software with AI coding agents (e.g., Claude Code, Codex, or other agent runtimes). The product externalizes project planning, state, decisions, and execution history into durable, inspectable artifacts, enabling short-lived, task-scoped agent sessions to reliably deliver work without needing long-lived conversational context.\n\nThe core workflow is:\n\n1. define a structured feature/task graph where every node has an associated agent prompt,\n2. compute what work is actionable based on dependencies and current status,\n3. select and queue work from the terminal,\n4. run agents against specific tasks with a consistent “context pack” (project snapshot + task prompt + relevant prior outputs),\n5. continuously track and surface progress in a live CLI dashboard,\n6. allow agents to request clarification/confirmation from the user with prominent alerts and inline responses,\n7. continuously maintain a concise “current state of the app” summary for new agent runs.\n\nThe product is designed to make AI work reliable, repeatable, and coordinated across many agent invocations by treating memory and task structure as first-class artifacts.\n\n---\n\nexec\n/bin/zsh -lc 'cat AGENT_LOG.md' in /Users/jackbonatakis/repos/blackbird succeeded in 117ms:\n# AGENT_LOG\n\n## 2026-01-18 — Phase 1 implementation plan (initial)\n\n- Phase 1 target per `specs/phase_1/PHASE_1.md`: planning-only agent integration (generate/refine/deps infer), durable plan file, validation/explainability, and a usable ready-task loop (list/show/pick + manual status updates).\n- Keep dependencies low and the implementation clear (Go-first).\n- Prefer a single, human-readable plan file stored at repo root; use JSON to avoid YAML dependencies.\n- Agent runtime integration will be pluggable via an external command hook that returns machine-readable JSON (full plan or patch ops), with a manual-mode fallback.\n\n## 2026-01-18 — Repo organization update\n\n- Moved Phase 1 spec into `specs/phase_1/PHASE_1.md`.\n- Added `specs/phase_1/IMPLEMENTATION_PLAN.md` capturing the Phase 1 build order and architecture.\n\n## 2026-01-18 — Phase 1 milestone sub-specs\n\n- Created one sub-spec per Phase 1 milestone under `specs/phase_1/milestones/` (M1–M6).\n- Linked milestone docs from `specs/phase_1/IMPLEMENTATION_PLAN.md`.\n\n## 2026-01-18 — M1: Foundation (Go module + Plan IO + Atomic Writes + Validate)\n\nthinking\n**Inspecting model.go for update**\n\nI'm reviewing internal/tui/model.go to understand where and how to update AGENT_LOG as required.\nexec\n/bin/zsh -lc \"sed -n '1,240p' internal/tui/model.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 110ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\ntype ActionMode int\n\nconst (\n\tActionModeNone ActionMode = iota\n\tActionModeSetStatus\n)\n\ntype Model struct {\n\tplan             plan.WorkGraph\n\nthinking\n**Verifying navigation implementation location**\n\nI'll check other files to see if navigation logic is implemented in the model or elsewhere before proceeding.\nexec\n/bin/zsh -lc \"sed -n '1,260p' internal/tui/tree_view.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 117ms:\npackage tui\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\ntype FilterMode int\n\nconst (\n\tFilterModeAll FilterMode = iota\n\tFilterModeReady\n\tFilterModeBlocked\n)\n\nfunc RenderTreeView(model Model) string {\n\tif len(model.plan.Items) == 0 {\n\nthinking\n**Planning model helpers and detail view**\n\nNext, I'll add helper functions to the model and review the detail view implementation to verify if scrolling behavior is handled there.\nexec\n/bin/zsh -lc \"sed -n '1,260p' internal/tui/detail_view.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 71ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/bubbles/viewport\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nfunc RenderDetailView(model Model) string {\n\tif model.selectedID == \"\" {\n\t\treturn emptyDetailView(\"No item selected.\")\n\t}\n\tit, ok := model.plan.Items[model.selectedID]\n\tif !ok {\n\t\treturn emptyDetailView(fmt.Sprintf(\"Unknown item %q.\", model.selectedID))\n\t}\n\nthinking\n**Noticing missing viewport state**\n\nI found that the viewport is recreated on each call, so scrolling isn't preserved; this implies viewport state likely needs to be stored in the model and should be searched for there.\nexec\n/bin/zsh -lc 'rg \"viewport\" -n internal/tui' in /Users/jackbonatakis/repos/blackbird succeeded in 109ms:\ninternal/tui/detail_view.go:8:\t\"github.com/charmbracelet/bubbles/viewport\"\ninternal/tui/detail_view.go:146:\tview := viewport.New(width, height)\n\nthinking\n**Considering viewport state for scrolling**\n\nThe user notes the need to support page up/down scrolling in the detail pane, implying the model requires a viewport to track visible items. They plan to enhance the update method, add helper functions for navigation, and possibly add activePane tracking after checking related files.\nexec\n/bin/zsh -lc 'rg \"activePane\" -n internal/tui' in /Users/jackbonatakis/repos/blackbird exited 1 in 107ms:\n\n\nthinking\n**Investigating model for activePane**\n\nI'm inspecting the model structure to confirm the presence of an activePane field and exploring the internal/tui directory for a view layout or TUI view component that manages pane states.\nexec\n/bin/zsh -lc 'rg \"Render\" -n internal/tui' in /Users/jackbonatakis/repos/blackbird succeeded in 103ms:\ninternal/tui/execution_view_test.go:13:func TestRenderExecutionViewActiveRun(t *testing.T) {\ninternal/tui/execution_view_test.go:59:\tout := RenderExecutionView(model)\ninternal/tui/execution_view_test.go:77:func TestRenderExecutionViewEmptyState(t *testing.T) {\ninternal/tui/execution_view_test.go:79:\tout := RenderExecutionView(model)\ninternal/tui/detail_view.go:13:func RenderDetailView(model Model) string {\ninternal/tui/detail_view.go:37:\t\tb.WriteString(mutedStyle.Render(\"(none)\") + \"\\n\\n\")\ninternal/tui/detail_view.go:45:\t\tb.WriteString(mutedStyle.Render(\"(none)\") + \"\\n\\n\")\ninternal/tui/detail_view.go:57:\t\tb.WriteString(mutedStyle.Render(\"(none)\") + \"\\n\\n\")\ninternal/tui/detail_view.go:73:\t\tb.WriteString(mutedStyle.Render(\"(none)\") + \"\\n\\n\")\ninternal/tui/detail_view.go:102:\t\tb.WriteString(mutedStyle.Render(\"(empty)\") + \"\\n\")\ninternal/tui/detail_view.go:116:\treturn style.Render(message)\ninternal/tui/detail_view.go:120:\tb.WriteString(style.Render(title))\ninternal/tui/detail_view.go:125:\tb.WriteString(labelStyle.Render(label + \": \"))\ninternal/tui/model.go:163:\t\treturn content + \"\\n\" + RenderBottomBar(m)\ninternal/tui/model.go:165:\treturn RenderBottomBar(m)\ninternal/tui/detail_view_test.go:11:func TestRenderDetailView(t *testing.T) {\ninternal/tui/detail_view_test.go:26:\t\t\t\tDescription:        \"Render the full details pane.\",\ninternal/tui/detail_view_test.go:51:\tout := RenderDetailView(model)\ninternal/tui/detail_view_test.go:70:func TestRenderDetailViewEmptySelection(t *testing.T) {\ninternal/tui/detail_view_test.go:72:\tout := RenderDetailView(model)\n\nthinking\n**Examining active pane management**\n\nI'm checking whether the model handles active pane updates since the view seems placeholder and the detail pane is separate; next, I'll inspect bottom bar code to understand where activePane is expected or managed.\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/tui/bottom_bar.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 102ms:\npackage tui\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/jbonatakis/blackbird/internal/execution\"\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nvar spinnerFrames = []string{\"|\", \"/\", \"-\", \"\\\\\"}\n\nfunc RenderBottomBar(model Model) string {\n\treadyCount := len(execution.ReadyTasks(model.plan))\n\tblockedCount := blockedCount(model.plan)\n\n\tactions := actionHints(model, readyCount)\n\tleft := strings.Join(actions, \" \")\n\n\n\nthinking\n**Planning navigation state updates**\n\nI'm outlining updates to the model state to track active pane and detail scroll offset for handling key inputs like tab, filter toggle, and detail scrolling; this likely requires adding detail viewport state in the model despite view code being mostly stateless.\nthinking\n**Searching for detail state usage**\nexec\n/bin/zsh -lc 'rg \"detail\" -n internal/tui/model.go internal/tui/*.go' in /Users/jackbonatakis/repos/blackbird succeeded in 95ms:\ninternal/tui/detail_view_test.go:25:\t\t\t\tTitle:              \"Build detail view\",\ninternal/tui/detail_view_test.go:26:\t\t\t\tDescription:        \"Render the full details pane.\",\ninternal/tui/detail_view_test.go:54:\tassertContains(t, out, \"Title: Build detail view\")\n\n\nthinking\n**Planning pane state and scrolling**\n\nI'm deciding to add active pane tracking and a detail pane scroll offset to the model for proper focus switching and scrolling, implementing visible item navigation respecting tree order, expansion, and filtering mostly in model.go, while preparing to adjust detail_view.go as needed for detail offset rendering.\nthinking\n**Expanding navigation and filtering logic**\n\nI'm designing recursion to compute visible tree items respecting filtering and expansion, then implementing selection movement (next/prev/home/end) over that list with seamless updates on filter changes. I'll add active pane gating for key handling, page up/down scrolling for detail with offset clamping, and toggling expansion only on parent nodes, while resetting detail scroll on selection changes.\nexec\n/bin/zsh -lc 'rg \"Model\" internal/tui -g\"*_test.go\"' in /Users/jackbonatakis/repos/blackbird succeeded in 103ms:\ninternal/tui/detail_view_test.go:\tmodel := Model{\ninternal/tui/detail_view_test.go:\tmodel := Model{}\ninternal/tui/execution_view_test.go:\tmodel := Model{\ninternal/tui/execution_view_test.go:\tmodel := Model{}\ninternal/tui/run_loader_test.go:\tmodel := Model{\ninternal/tui/run_loader_test.go:\tmodel := Model{\n\nthinking\n**Planning model tests**\n\nI'm prioritizing tests for next/prev navigation with filters and collapsed states, adding a new model test file, and reviewing plan.WorkGraph and plan types to support test construction.\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/plan/types.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 63ms:\npackage plan\n\nimport \"time\"\n\nconst (\n\tDefaultPlanFilename = \"blackbird.plan.json\"\n\tSchemaVersion       = 1\n)\n\ntype WorkGraph struct {\n\tSchemaVersion int                 `json:\"schemaVersion\"`\n\tItems         map[string]WorkItem `json:\"items\"`\n}\n\ntype Status string\n\nconst (\n\tStatusTodo       Status = \"todo\"\n\tStatusQueued     Status = \"queued\"\n\tStatusInProgress Status = \"in_progress\"\n\nthinking\n**Checking filters for readiness label**\nexec\n/bin/zsh -lc \"sed -n '1,200p' internal/plan/readiness.go\" in /Users/jackbonatakis/repos/blackbird succeeded in 63ms:\npackage plan\n\n// ReadinessLabel returns a display label for readiness derived from status and deps.\nfunc ReadinessLabel(status Status, depsOK bool, manualBlocked bool) string {\n\tif status == StatusDone {\n\t\treturn \"DONE\"\n\t}\n\tif status == StatusSkipped {\n\t\treturn \"SKIPPED\"\n\t}\n\tif status == StatusInProgress {\n\t\treturn \"IN_PROGRESS\"\n\t}\n\tif status == StatusQueued {\n\t\treturn \"QUEUED\"\n\t}\n\tif status == StatusWaitingUser {\n\t\treturn \"WAITING_USER\"\n\t}\n\tif status == StatusFailed {\n\n\nthinking\n**Planning detail pane scrolling and key navigation**\n\nI'm outlining key navigation to jump to first/last visible items in tree view and page up/down scrolling in detail pane with clamped offsets. Detail offset resets on selection or filter changes, and clamping logic will prevent negative offsets while respecting content length.\nthinking\n**Adding detail offset and active pane to model**\n\nI'm planning to add activePane and detailOffset fields to the model and update detail view scrolling by clamping detailOffset in applyViewport without modifying the model directly. I'll also implement navigation helpers and key handling logic tied to activePane.\nfile update\nM /Users/jackbonatakis/repos/blackbird/internal/tui/model.go\n@@ -18,2 +18,9 @@\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n@@ -23,2 +30,3 @@\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n@@ -32,2 +40,3 @@\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n@@ -38,2 +47,3 @@\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n@@ -112,2 +122,9 @@\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n@@ -115,2 +132,87 @@\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n@@ -172 +274,149 @@\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\napply_patch(auto_approved=true) exited 0 in 51ms:\nSuccess. Updated the following files:\nM internal/tui/model.go\nfile update:\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..dba6d43212c960449efd3ad48de47bf537440ceb\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -16,11 +16,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +38,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +120,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +272,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\n\nfile update:\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..dba6d43212c960449efd3ad48de47bf537440ceb\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -16,11 +16,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +38,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +120,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +272,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\n\n\nthinking\n**Fixing missing import**\n\nI'm adding the missing import for the sort package in model.go to enable sorting functionality properly.\nfile update\nM /Users/jackbonatakis/repos/blackbird/internal/tui/model.go\n@@ -4,2 +4,3 @@\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\napply_patch(auto_approved=true) exited 0 in 62ms:\nSuccess. Updated the following files:\nM internal/tui/model.go\nfile update:\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\n\nfile update:\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\n\n\nthinking\n**Planning Go code formatting and detailOffset update**\nfile update\nM /Users/jackbonatakis/repos/blackbird/internal/tui/detail_view.go\n@@ -147,2 +147,15 @@\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\napply_patch(auto_approved=true) exited 0 in 52ms:\nSuccess. Updated the following files:\nM internal/tui/detail_view.go\nfile update:\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\n\nfile update:\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\n\n\n\nthinking\n**Planning tests for visibility and filtering**\n\nI'm designing tests for visible item order and filtering using a simple graph to verify collapse behavior and readiness-based filtering, focusing on next/previous visible item logic and selection visibility.\nthinking\n**Designing filter mode tests with dependency cases**\n\nI'm defining tests for blocked filter mode showing parents of blocked items and verifying selection visibility updates on filter changes, using helper functions to build work item graphs with dependencies reflecting readiness states.\nfile update\nA /Users/jackbonatakis/repos/blackbird/internal/tui/model_test.go\npackage tui\n\nimport (\n\t\"testing\"\n\n\t\"github.com/jbonatakis/blackbird/internal/plan\"\n)\n\nfunc TestVisibleNavigationRespectsExpanded(t *testing.T) {\n\tg := plan.WorkGraph{\n\t\tItems: map[string]plan.WorkItem{},\n\t}\n\n\trootID := \"A\"\n\tchildB := \"B\"\n\tchildC := \"C\"\n\tchildD := \"D\"\n\n\tg.Items[rootID] = plan.WorkItem{\n\t\tID:       rootID,\n\t\tChildIDs: []string{childB, childC},\n\t\tStatus:   plan.StatusTodo,\n\t}\n\tg.Items[childB] = plan.WorkItem{\n\t\tID:       childB,\n\t\tParentID: \u0026rootID,\n\t\tChildIDs: []string{childD},\n\t\tStatus:   plan.StatusTodo,\n\t}\n\tg.Items[childC] = plan.WorkItem{\n\t\tID:       childC,\n\t\tParentID: \u0026rootID,\n\t\tStatus:   plan.StatusTodo,\n\t}\n\tg.Items[childD] = plan.WorkItem{\n\t\tID:       childD,\n\t\tParentID: \u0026childB,\n\t\tStatus:   plan.StatusTodo,\n\t}\n\n\tmodel := Model{\n\t\tplan:          g,\n\t\tfilterMode:    FilterModeAll,\n\t\texpandedItems: map[string]bool{},\n\t\tselectedID:    childB,\n\t}\n\n\tif next := model.nextVisibleItem(); next != childD {\n\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n\t}\n\tif prev := model.prevVisibleItem(); prev != rootID {\n\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n\t}\n\n\tmodel.expandedItems[rootID] = false\n\tmodel.selectedID = childD\n\tmodel.ensureSelectionVisible()\n\tif model.selectedID != rootID {\n\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n\t}\n}\n\nfunc TestFilterModeBlockedIncludesParents(t *testing.T) {\n\tg := plan.WorkGraph{\n\t\tItems: map[string]plan.WorkItem{},\n\t}\n\n\trootID := \"R\"\n\tchildA := \"A\"\n\tchildB := \"B\"\n\tdepID := \"X\"\n\n\tg.Items[rootID] = plan.WorkItem{\n\t\tID:       rootID,\n\t\tChildIDs: []string{childA, childB},\n\t\tStatus:   plan.StatusTodo,\n\t}\n\tg.Items[childA] = plan.WorkItem{\n\t\tID:       childA,\n\t\tParentID: \u0026rootID,\n\t\tDeps:     []string{depID},\n\t\tStatus:   plan.StatusTodo,\n\t}\n\tg.Items[childB] = plan.WorkItem{\n\t\tID:       childB,\n\t\tParentID: \u0026rootID,\n\t\tStatus:   plan.StatusTodo,\n\t}\n\tg.Items[depID] = plan.WorkItem{\n\t\tID:     depID,\n\t\tStatus: plan.StatusTodo,\n\t}\n\n\tmodel := Model{\n\t\tplan:          g,\n\t\tfilterMode:    FilterModeBlocked,\n\t\texpandedItems: map[string]bool{},\n\t\tselectedID:    childB,\n\t}\n\n\tmodel.ensureSelectionVisible()\n\tif model.selectedID != rootID {\n\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n\t}\n\n\tvisible := model.visibleItemIDs()\n\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n\t}\n}\napply_patch(auto_approved=true) exited 0 in 94ms:\nSuccess. Updated the following files:\nA internal/tui/model_test.go\nfile update:\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\nfile update:\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\n\nthinking\n**Noting import sorting and formatting needs**\nexec\n/bin/zsh -lc 'gofmt -w internal/tui/model.go internal/tui/detail_view.go internal/tui/model_test.go' in /Users/jackbonatakis/repos/blackbird succeeded in 111ms:\n\nfile update:\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\n\nthinking\n**Preparing to run targeted Go tests**\n\nI'm planning to run `go test` specifically on the internal tui package despite possible module fetch issues, since it seems minimal dependencies might be involved and previous failures were related to missing modules more broadly.\nexec\n/bin/zsh -lc 'go test ./internal/tui/...' in /Users/jackbonatakis/repos/blackbird exited 1 in 127ms:\nFAIL\t./internal/tui/... [setup failed]\n# ./internal/tui/...\npattern ./internal/tui/...: open /Users/jackbonatakis/Library/Caches/go-build/0d/0d48adec95d469447f0012939777645648581e3e4e018fa96c268573987981c7-d: operation not permitted\nFAIL\nfile update:\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\n\nthinking\n**Logging agent action**\n\nI'm adding a note to AGENT_LOG to record the latest action in the agent's workflow.\nfile update\nM /Users/jackbonatakis/repos/blackbird/AGENT_LOG.md\n@@ -345 +345,9 @@\n - Extended TUI model to track `expandedItems` and `filterMode` defaults for upcoming navigation/filter work.\n+\n+## 2026-01-29 — TUI keyboard navigation + detail scrolling\n+\n+- Added keyboard navigation handling in `internal/tui/model.go` for tree movement (up/down, j/k, home/end), expand/collapse (enter/space), pane toggle (tab), and filter cycling (f).\n+- Implemented visible-item traversal helpers and parent detection to keep selection aligned with render order and filter state.\n+- Added detail pane paging state and applied `pgup/pgdown` scrolling via the viewport offset in `internal/tui/detail_view.go`.\n+- Added unit tests for visible navigation, filter behavior, and selection snapping in `internal/tui/model_test.go`.\n+- `go test ./internal/tui/...` failed due to Go build cache permissions in this environment (`operation not permitted`).\napply_patch(auto_approved=true) exited 0 in 68ms:\nSuccess. Updated the following files:\nM AGENT_LOG.md\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 3540a466a11baaee605255bc8e2cb66a029a5422..8c6c77861a8489dd20ce7890d0d389f6f3c4ec1f\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -343,3 +343,11 @@\n - Added `internal/tui/tree_view.go` with hierarchical plan tree rendering, expand/collapse handling, selection highlight, and status/readiness styling via lipgloss.\n - Introduced `plan.ReadinessLabel` for shared readiness labeling; updated CLI list/pick paths to use it.\n - Extended TUI model to track `expandedItems` and `filterMode` defaults for upcoming navigation/filter work.\n+\n+## 2026-01-29 — TUI keyboard navigation + detail scrolling\n+\n+- Added keyboard navigation handling in `internal/tui/model.go` for tree movement (up/down, j/k, home/end), expand/collapse (enter/space), pane toggle (tab), and filter cycling (f).\n+- Implemented visible-item traversal helpers and parent detection to keep selection aligned with render order and filter state.\n+- Added detail pane paging state and applied `pgup/pgdown` scrolling via the viewport offset in `internal/tui/detail_view.go`.\n+- Added unit tests for visible navigation, filter behavior, and selection snapping in `internal/tui/model_test.go`.\n+- `go test ./internal/tui/...` failed due to Go build cache permissions in this environment (`operation not permitted`).\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 3540a466a11baaee605255bc8e2cb66a029a5422..8c6c77861a8489dd20ce7890d0d389f6f3c4ec1f\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -343,3 +343,11 @@\n - Added `internal/tui/tree_view.go` with hierarchical plan tree rendering, expand/collapse handling, selection highlight, and status/readiness styling via lipgloss.\n - Introduced `plan.ReadinessLabel` for shared readiness labeling; updated CLI list/pick paths to use it.\n - Extended TUI model to track `expandedItems` and `filterMode` defaults for upcoming navigation/filter work.\n+\n+## 2026-01-29 — TUI keyboard navigation + detail scrolling\n+\n+- Added keyboard navigation handling in `internal/tui/model.go` for tree movement (up/down, j/k, home/end), expand/collapse (enter/space), pane toggle (tab), and filter cycling (f).\n+- Implemented visible-item traversal helpers and parent detection to keep selection aligned with render order and filter state.\n+- Added detail pane paging state and applied `pgup/pgdown` scrolling via the viewport offset in `internal/tui/detail_view.go`.\n+- Added unit tests for visible navigation, filter behavior, and selection snapping in `internal/tui/model_test.go`.\n+- `go test ./internal/tui/...` failed due to Go build cache permissions in this environment (`operation not permitted`).\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..f36b802dd9a659c7f76d7c2d650bf26391aa90ca\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\n\nthinking\n**Expanding page up/down keys**\n\nPlanning to update key handling to include both \"pgup\"/\"pgdown\" and \"pageup\"/\"pagedown\" variants for more robust support; also confirming early return on action mode and ensuring sorting import is added.\nfile update\nM /Users/jackbonatakis/repos/blackbird/internal/tui/model.go\n@@ -197,3 +197,3 @@\n \t\t\treturn m, nil\n-\t\tcase \"pgup\":\n+\t\tcase \"pgup\", \"pageup\":\n \t\t\tif m.activePane != PaneDetail {\n@@ -209,3 +209,3 @@\n \t\t\treturn m, nil\n-\t\tcase \"pgdown\":\n+\t\tcase \"pgdown\", \"pagedown\":\n \t\t\tif m.activePane != PaneDetail {\napply_patch(auto_approved=true) exited 0 in 118ms:\nSuccess. Updated the following files:\nM internal/tui/model.go\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 3540a466a11baaee605255bc8e2cb66a029a5422..8c6c77861a8489dd20ce7890d0d389f6f3c4ec1f\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -343,3 +343,11 @@\n - Added `internal/tui/tree_view.go` with hierarchical plan tree rendering, expand/collapse handling, selection highlight, and status/readiness styling via lipgloss.\n - Introduced `plan.ReadinessLabel` for shared readiness labeling; updated CLI list/pick paths to use it.\n - Extended TUI model to track `expandedItems` and `filterMode` defaults for upcoming navigation/filter work.\n+\n+## 2026-01-29 — TUI keyboard navigation + detail scrolling\n+\n+- Added keyboard navigation handling in `internal/tui/model.go` for tree movement (up/down, j/k, home/end), expand/collapse (enter/space), pane toggle (tab), and filter cycling (f).\n+- Implemented visible-item traversal helpers and parent detection to keep selection aligned with render order and filter state.\n+- Added detail pane paging state and applied `pgup/pgdown` scrolling via the viewport offset in `internal/tui/detail_view.go`.\n+- Added unit tests for visible navigation, filter behavior, and selection snapping in `internal/tui/model_test.go`.\n+- `go test ./internal/tui/...` failed due to Go build cache permissions in this environment (`operation not permitted`).\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..726a124d99a2cae6b482e683b2f08ef0aee9b185\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\", \"pageup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\", \"pagedown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 3540a466a11baaee605255bc8e2cb66a029a5422..8c6c77861a8489dd20ce7890d0d389f6f3c4ec1f\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -343,3 +343,11 @@\n - Added `internal/tui/tree_view.go` with hierarchical plan tree rendering, expand/collapse handling, selection highlight, and status/readiness styling via lipgloss.\n - Introduced `plan.ReadinessLabel` for shared readiness labeling; updated CLI list/pick paths to use it.\n - Extended TUI model to track `expandedItems` and `filterMode` defaults for upcoming navigation/filter work.\n+\n+## 2026-01-29 — TUI keyboard navigation + detail scrolling\n+\n+- Added keyboard navigation handling in `internal/tui/model.go` for tree movement (up/down, j/k, home/end), expand/collapse (enter/space), pane toggle (tab), and filter cycling (f).\n+- Implemented visible-item traversal helpers and parent detection to keep selection aligned with render order and filter state.\n+- Added detail pane paging state and applied `pgup/pgdown` scrolling via the viewport offset in `internal/tui/detail_view.go`.\n+- Added unit tests for visible navigation, filter behavior, and selection snapping in `internal/tui/model_test.go`.\n+- `go test ./internal/tui/...` failed due to Go build cache permissions in this environment (`operation not permitted`).\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..726a124d99a2cae6b482e683b2f08ef0aee9b185\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\", \"pageup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\", \"pagedown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\n\nthinking\n**Deciding on gofmt usage**\n\nI'm deciding to run gofmt on model.go to ensure consistent formatting, though it's not strictly necessary.\nexec\n/bin/zsh -lc 'gofmt -w internal/tui/model.go' in /Users/jackbonatakis/repos/blackbird succeeded in 100ms:\n\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 3540a466a11baaee605255bc8e2cb66a029a5422..8c6c77861a8489dd20ce7890d0d389f6f3c4ec1f\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -343,3 +343,11 @@\n - Added `internal/tui/tree_view.go` with hierarchical plan tree rendering, expand/collapse handling, selection highlight, and status/readiness styling via lipgloss.\n - Introduced `plan.ReadinessLabel` for shared readiness labeling; updated CLI list/pick paths to use it.\n - Extended TUI model to track `expandedItems` and `filterMode` defaults for upcoming navigation/filter work.\n+\n+## 2026-01-29 — TUI keyboard navigation + detail scrolling\n+\n+- Added keyboard navigation handling in `internal/tui/model.go` for tree movement (up/down, j/k, home/end), expand/collapse (enter/space), pane toggle (tab), and filter cycling (f).\n+- Implemented visible-item traversal helpers and parent detection to keep selection aligned with render order and filter state.\n+- Added detail pane paging state and applied `pgup/pgdown` scrolling via the viewport offset in `internal/tui/detail_view.go`.\n+- Added unit tests for visible navigation, filter behavior, and selection snapping in `internal/tui/model_test.go`.\n+- `go test ./internal/tui/...` failed due to Go build cache permissions in this environment (`operation not permitted`).\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..726a124d99a2cae6b482e683b2f08ef0aee9b185\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\", \"pageup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\", \"pagedown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\n\nthinking\n**Summarizing changes and test results**\n\nThe code changes involved updating model.go and related files with use of plan.UnmetDeps and ReadinessLabel, and sorting imports. Tests were run but failed due to Go build cache permission issues, preventing full verification. The activePane value is present but not yet wired into the view rendering.\n\nNext steps include running `go test` with proper permissions (e.g., in `./internal/tui/`), verifying key handling like pageup/pagedown in the UI, and considering wiring activePane into the detail pane rendering with height adjustment for page size.\ncodex\nAdded keyboard navigation in the TUI model: tree movement (arrows/j/k, home/end), expand/collapse (enter/space), pane toggle (tab), filter cycling (f), and detail paging (pgup/pgdown). This includes new visible-item traversal helpers to keep selection aligned with the rendered tree order and filter mode, plus selection snapping when filters or collapse hide the current item. Detail pane paging now uses a stored offset that’s clamped in `internal/tui/detail_view.go`. Added tests covering visible navigation and blocked-filter behavior.\n\nTests\n- `go test ./internal/tui/...` (failed: Go build cache permission error: `operation not permitted`)\n\nFiles touched\n- `internal/tui/model.go`\n- `internal/tui/detail_view.go`\n- `internal/tui/model_test.go`\n- `AGENT_LOG.md`\n\nSuggestions\n1) Re-run `go test ./internal/tui/...` in an environment where the Go build cache is writable.  \n2) Verify key handling in the TUI once the pane layout uses `activePane` to visually indicate focus.\nfile update:\ndiff --git a/AGENT_LOG.md b/AGENT_LOG.md\nindex 3540a466a11baaee605255bc8e2cb66a029a5422..8c6c77861a8489dd20ce7890d0d389f6f3c4ec1f\n--- a/AGENT_LOG.md\n+++ b/AGENT_LOG.md\n@@ -343,3 +343,11 @@\n - Added `internal/tui/tree_view.go` with hierarchical plan tree rendering, expand/collapse handling, selection highlight, and status/readiness styling via lipgloss.\n - Introduced `plan.ReadinessLabel` for shared readiness labeling; updated CLI list/pick paths to use it.\n - Extended TUI model to track `expandedItems` and `filterMode` defaults for upcoming navigation/filter work.\n+\n+## 2026-01-29 — TUI keyboard navigation + detail scrolling\n+\n+- Added keyboard navigation handling in `internal/tui/model.go` for tree movement (up/down, j/k, home/end), expand/collapse (enter/space), pane toggle (tab), and filter cycling (f).\n+- Implemented visible-item traversal helpers and parent detection to keep selection aligned with render order and filter state.\n+- Added detail pane paging state and applied `pgup/pgdown` scrolling via the viewport offset in `internal/tui/detail_view.go`.\n+- Added unit tests for visible navigation, filter behavior, and selection snapping in `internal/tui/model_test.go`.\n+- `go test ./internal/tui/...` failed due to Go build cache permissions in this environment (`operation not permitted`).\ndiff --git a/internal/tui/detail_view.go b/internal/tui/detail_view.go\nindex 181454b504a16970078158937fa73fe0061cc9bf..80e78371122bb485cbe7042d25cb6e09087b0c3e\n--- a/internal/tui/detail_view.go\n+++ b/internal/tui/detail_view.go\n@@ -145,5 +145,18 @@\n \t}\n \tview := viewport.New(width, height)\n \tview.SetContent(content)\n+\toffset := model.detailOffset\n+\tif offset \u003c 0 {\n+\t\toffset = 0\n+\t}\n+\ttotalLines := len(strings.Split(content, \"\\n\"))\n+\tmaxOffset := totalLines - height\n+\tif maxOffset \u003c 0 {\n+\t\tmaxOffset = 0\n+\t}\n+\tif offset \u003e maxOffset {\n+\t\toffset = maxOffset\n+\t}\n+\tview.YOffset = offset\n \treturn view.View()\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex dae1d5c34741ede5b330da1f99397cfbc557e1c3..726a124d99a2cae6b482e683b2f08ef0aee9b185\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -2,6 +2,7 @@\n \n import (\n \t\"fmt\"\n+\t\"sort\"\n \t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n@@ -16,11 +17,19 @@\n \tActionModeSetStatus\n )\n \n+type ActivePane int\n+\n+const (\n+\tPaneTree ActivePane = iota\n+\tPaneDetail\n+)\n+\n type Model struct {\n \tplan             plan.WorkGraph\n \tselectedID       string\n \tpendingStatusID  string\n \tactionMode       ActionMode\n+\tactivePane       ActivePane\n \twindowWidth      int\n \twindowHeight     int\n \tactionInProgress bool\n@@ -30,12 +39,14 @@\n \ttimerActive      bool\n \texpandedItems    map[string]bool\n \tfilterMode       FilterMode\n+\tdetailOffset     int\n }\n \n func NewModel(g plan.WorkGraph) Model {\n \tm := Model{\n \t\tplan:          g,\n \t\tactionMode:    ActionModeNone,\n+\t\tactivePane:    PaneTree,\n \t\trunData:       map[string]execution.RunRecord{},\n \t\texpandedItems: map[string]bool{},\n \t\tfilterMode:    FilterModeAll,\n@@ -110,9 +121,101 @@\n \t\t}\n \t\treturn m, nil\n \tcase tea.KeyMsg:\n+\t\tif m.actionMode == ActionModeSetStatus {\n+\t\t\tswitch typed.String() {\n+\t\t\tcase \"ctrl+c\", \"q\":\n+\t\t\t\treturn m, tea.Quit\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n \t\tswitch typed.String() {\n \t\tcase \"ctrl+c\", \"q\":\n \t\t\treturn m, tea.Quit\n+\t\tcase \"tab\":\n+\t\t\tif m.activePane == PaneTree {\n+\t\t\t\tm.activePane = PaneDetail\n+\t\t\t} else {\n+\t\t\t\tm.activePane = PaneTree\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"f\":\n+\t\t\tm.filterMode = nextFilterMode(m.filterMode)\n+\t\t\tm.ensureSelectionVisible()\n+\t\t\tm.detailOffset = 0\n+\t\t\treturn m, nil\n+\t\tcase \"up\", \"k\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.prevVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"down\", \"j\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tnext := m.nextVisibleItem()\n+\t\t\tif next != \"\" \u0026\u0026 next != m.selectedID {\n+\t\t\t\tm.selectedID = next\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"home\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 \u0026\u0026 m.selectedID != visible[0] {\n+\t\t\t\tm.selectedID = visible[0]\n+\t\t\t\tm.detailOffset = 0\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"end\":\n+\t\t\tif m.activePane != PaneTree {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tvisible := m.visibleItemIDs()\n+\t\t\tif len(visible) \u003e 0 {\n+\t\t\t\tlast := visible[len(visible)-1]\n+\t\t\t\tif m.selectedID != last {\n+\t\t\t\t\tm.selectedID = last\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"enter\", \" \":\n+\t\t\tif m.activePane != PaneTree || m.selectedID == \"\" {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tif m.isParent(m.selectedID) {\n+\t\t\t\tm.toggleExpanded(m.selectedID)\n+\t\t\t\tm.ensureSelectionVisible()\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgup\", \"pageup\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset -= page\n+\t\t\t\tif m.detailOffset \u003c 0 {\n+\t\t\t\t\tm.detailOffset = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn m, nil\n+\t\tcase \"pgdown\", \"pagedown\":\n+\t\t\tif m.activePane != PaneDetail {\n+\t\t\t\treturn m, nil\n+\t\t\t}\n+\t\t\tpage := m.detailPageSize()\n+\t\t\tif page \u003e 0 {\n+\t\t\t\tm.detailOffset += page\n+\t\t\t}\n+\t\t\treturn m, nil\n \t\tcase \"g\":\n \t\t\tif m.actionMode != ActionModeNone || m.actionInProgress {\n \t\t\t\treturn m, nil\n@@ -170,3 +273,151 @@\n \t\treturn spinnerTickMsg{}\n \t})\n }\n+\n+func (m Model) nextVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i+1 \u003c len(visible) {\n+\t\t\t\treturn visible[i+1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) prevVisibleItem() string {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\treturn visible[0]\n+\t}\n+\tfor i, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\tif i-1 \u003e= 0 {\n+\t\t\t\treturn visible[i-1]\n+\t\t\t}\n+\t\t\treturn id\n+\t\t}\n+\t}\n+\treturn visible[0]\n+}\n+\n+func (m Model) isParent(id string) bool {\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn len(it.ChildIDs) \u003e 0\n+}\n+\n+func (m Model) visibleItemIDs() []string {\n+\troots := rootIDs(m.plan)\n+\tvisited := map[string]bool{}\n+\tout := make([]string, 0)\n+\tfor _, id := range roots {\n+\t\titems, _ := m.visibleBranch(id, visited)\n+\t\tout = append(out, items...)\n+\t}\n+\treturn out\n+}\n+\n+func (m Model) visibleBranch(id string, visited map[string]bool) ([]string, bool) {\n+\tif visited[id] {\n+\t\treturn nil, false\n+\t}\n+\tvisited[id] = true\n+\tit, ok := m.plan.Items[id]\n+\tif !ok {\n+\t\treturn nil, false\n+\t}\n+\tchildren := append([]string{}, it.ChildIDs...)\n+\tsort.Strings(children)\n+\n+\tdepsOK := len(plan.UnmetDeps(m.plan, it)) == 0\n+\tlabel := plan.ReadinessLabel(it.Status, depsOK, it.Status == plan.StatusBlocked)\n+\tmatchesSelf := filterMatch(m.filterMode, label)\n+\n+\tisExpanded := isExpanded(m, it.ID)\n+\tvar childLines []string\n+\tvar childMatched bool\n+\tfor _, childID := range children {\n+\t\tlines, matched := m.visibleBranch(childID, visited)\n+\t\tif matched {\n+\t\t\tchildMatched = true\n+\t\t}\n+\t\tif isExpanded {\n+\t\t\tchildLines = append(childLines, lines...)\n+\t\t}\n+\t}\n+\n+\tshouldRender := matchesSelf || childMatched\n+\tif !shouldRender {\n+\t\treturn nil, false\n+\t}\n+\tlines := []string{it.ID}\n+\tif isExpanded {\n+\t\tlines = append(lines, childLines...)\n+\t}\n+\treturn lines, true\n+}\n+\n+func (m *Model) toggleExpanded(id string) {\n+\tif m.expandedItems == nil {\n+\t\tm.expandedItems = map[string]bool{}\n+\t}\n+\tif isExpanded(*m, id) {\n+\t\tm.expandedItems[id] = false\n+\t\treturn\n+\t}\n+\tm.expandedItems[id] = true\n+}\n+\n+func (m *Model) ensureSelectionVisible() {\n+\tvisible := m.visibleItemIDs()\n+\tif len(visible) == 0 {\n+\t\tm.selectedID = \"\"\n+\t\treturn\n+\t}\n+\tif m.selectedID == \"\" {\n+\t\tm.selectedID = visible[0]\n+\t\treturn\n+\t}\n+\tfor _, id := range visible {\n+\t\tif id == m.selectedID {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tm.selectedID = visible[0]\n+}\n+\n+func nextFilterMode(current FilterMode) FilterMode {\n+\tswitch current {\n+\tcase FilterModeAll:\n+\t\treturn FilterModeReady\n+\tcase FilterModeReady:\n+\t\treturn FilterModeBlocked\n+\tdefault:\n+\t\treturn FilterModeAll\n+\t}\n+}\n+\n+func (m Model) detailPageSize() int {\n+\theight := m.windowHeight\n+\tif height \u003e 0 {\n+\t\theight--\n+\t}\n+\tif height \u003c 0 {\n+\t\treturn 0\n+\t}\n+\treturn height\n+}\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..81282c88f02e265ccd14152a3027b7a7abac391d\n--- /dev/null\n+++ b/internal/tui/model_test.go\n@@ -0,0 +1,110 @@\n+package tui\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/jbonatakis/blackbird/internal/plan\"\n+)\n+\n+func TestVisibleNavigationRespectsExpanded(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"A\"\n+\tchildB := \"B\"\n+\tchildC := \"C\"\n+\tchildD := \"D\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childB, childC},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tChildIDs: []string{childD},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childC] = plan.WorkItem{\n+\t\tID:       childC,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childD] = plan.WorkItem{\n+\t\tID:       childD,\n+\t\tParentID: \u0026childB,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeAll,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tif next := model.nextVisibleItem(); next != childD {\n+\t\tt.Fatalf(\"expected next to be %q, got %q\", childD, next)\n+\t}\n+\tif prev := model.prevVisibleItem(); prev != rootID {\n+\t\tt.Fatalf(\"expected prev to be %q, got %q\", rootID, prev)\n+\t}\n+\n+\tmodel.expandedItems[rootID] = false\n+\tmodel.selectedID = childD\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to snap to %q, got %q\", rootID, model.selectedID)\n+\t}\n+}\n+\n+func TestFilterModeBlockedIncludesParents(t *testing.T) {\n+\tg := plan.WorkGraph{\n+\t\tItems: map[string]plan.WorkItem{},\n+\t}\n+\n+\trootID := \"R\"\n+\tchildA := \"A\"\n+\tchildB := \"B\"\n+\tdepID := \"X\"\n+\n+\tg.Items[rootID] = plan.WorkItem{\n+\t\tID:       rootID,\n+\t\tChildIDs: []string{childA, childB},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childA] = plan.WorkItem{\n+\t\tID:       childA,\n+\t\tParentID: \u0026rootID,\n+\t\tDeps:     []string{depID},\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[childB] = plan.WorkItem{\n+\t\tID:       childB,\n+\t\tParentID: \u0026rootID,\n+\t\tStatus:   plan.StatusTodo,\n+\t}\n+\tg.Items[depID] = plan.WorkItem{\n+\t\tID:     depID,\n+\t\tStatus: plan.StatusTodo,\n+\t}\n+\n+\tmodel := Model{\n+\t\tplan:          g,\n+\t\tfilterMode:    FilterModeBlocked,\n+\t\texpandedItems: map[string]bool{},\n+\t\tselectedID:    childB,\n+\t}\n+\n+\tmodel.ensureSelectionVisible()\n+\tif model.selectedID != rootID {\n+\t\tt.Fatalf(\"expected selection to move to %q, got %q\", rootID, model.selectedID)\n+\t}\n+\n+\tvisible := model.visibleItemIDs()\n+\tif len(visible) != 2 || visible[0] != rootID || visible[1] != childA {\n+\t\tt.Fatalf(\"expected visible items [ %s %s ], got %#v\", rootID, childA, visible)\n+\t}\n+}\n\ntokens used\n39,873\n",
  "context": {
    "schemaVersion": 1,
    "task": {
      "id": "navigation-keys",
      "title": "Implement keyboard navigation logic",
      "description": "Handle all keyboard inputs for navigating the tree (up/down), expanding/collapsing items (enter/space), switching panes (tab), filtering (f), and scrolling detail pane.",
      "acceptanceCriteria": [
        "Up/down arrows move selection in tree",
        "Enter or space expands/collapses parent items",
        "Tab switches focus between tree and detail panes",
        "f key cycles through filter modes (all/ready/blocked)",
        "j/k keys also work for vim-style navigation",
        "Page up/down scrolls detail pane",
        "Home/end keys jump to first/last item"
      ],
      "prompt": "Update internal/tui/model.go Update() method to handle tea.KeyMsg. Implement: arrow up/down to move selection through visible items in tree order (respecting collapsed state), enter/space to toggle expanded state for parents, tab to toggle activePane between 'tree' and 'detail', f to cycle filterMode, j/k as aliases for up/down, page up/down for detail scrolling. Update selectedID and expandedItems map accordingly. Add helper methods: nextVisibleItem(), prevVisibleItem(), isParent()."
    },
    "dependencies": [
      {
        "id": "tree-view",
        "title": "Build hierarchical plan tree view",
        "status": "done"
      },
      {
        "id": "detail-view",
        "title": "Build item detail pane view",
        "status": "done"
      }
    ],
    "projectSnapshot": "# Product Specification: AI-Orchestrated CLI for Structured, Dependency-Aware Software Delivery\n\n## 1. Product Summary\n\nA terminal-native product that functions as the authoritative “master memory” and execution control plane for building software with AI coding agents (e.g., Claude Code, Codex, or other agent runtimes). The product externalizes project planning, state, decisions, and execution history into durable, inspectable artifacts, enabling short-lived, task-scoped agent sessions to reliably deliver work without needing long-lived conversational context.\n\nThe core workflow is:\n\n1. define a structured feature/task graph where every node has an associated agent prompt,\n2. compute what work is actionable based on dependencies and current status,\n3. select and queue work from the terminal,\n4. run agents against specific tasks with a consistent “context pack” (project snapshot + task prompt + relevant prior outputs),\n5. continuously track and surface progress in a live CLI dashboard,\n6. allow agents to request clarification/confirmation from the user with prominent alerts and inline responses,\n7. continuously maintain a concise “current state of the app” summary for new agent runs.\n\nThe product is designed to make AI work reliable, repeatable, and coordinated across many agent invocations by treating memory and task structure as first-class artifacts.\n\n---\n\n## 2. Target Users\n\n### Primary\n\n* Solo developers and senior engineers building non-trivial systems who want:\n\n  * reliable continuity across many agent runs\n  * stronger control over what agents do\n  * a structured plan that stays synchronized with code reality\n\n### Secondary\n\n* Small teams coordinating AI-assisted work through a shared repo-local plan, where task structure and “project memory” are versioned artifacts.\n\n---\n\n## 3. Problems Solved\n\n1. **Loss of continuity across agent runs**\n\n   * Agents forget past context, causing rework and regressions.\n\n2. **Unreliable execution when context is oversized**\n\n   * Overloaded prompts reduce quality and increase drift.\n\n3. **Poor coordination between tasks**\n\n   * Flat lists and ad-hoc prompting don’t enforce ordering, dependencies, or readiness.\n\n4. **Weak visibility into what AI is doing**\n\n   * Users lack a clear real-time view of status, progress, logs, and time in state.\n\n5. **High friction when agents need human input**\n\n   * Agents often need confirmation or clarification; existing tooling doesn’t integrate user responses cleanly.\n\n6. **Parallelization without guardrails**\n\n   * Running multiple tasks concurrently can cause collisions and inconsistent outcomes.\n\n---\n\n## 4. Core Product Concepts\n\n### 4.1 Project “Master Memory”\n\nThe product maintains a durable, human-readable representation of project state that persists across sessions and can be used to seed new agent runs. This “master memory” is made of:\n\n* **Structured work graph**: the set of tasks/features, their hierarchy, and dependencies.\n* **Project snapshot**: a periodically refreshed summary of “current state of the app.”\n* **Decision log**: a record of key decisions and rationale to prevent re-deciding.\n\nThese artifacts are the source of truth for intent and context, reducing reliance on any single agent’s context window.\n\n### 4.2 Structured Work Graph (Feature Tree + Dependency DAG)\n\nWork is represented as a hierarchical tree for human comprehension and an explicit dependency graph for execution correctness.\n\n* **Tree**: features → subfeatures → tasks\n* **DAG**: prerequisite relationships that determine readiness and build order\n\nEach node in the graph is a first-class work item with metadata and a canonical agent prompt.\n\n### 4.3 Stateless, Task-Scoped Agent Execution\n\nAgents are treated as disposable workers:\n\n* each run has a bounded scope (a single task node)\n* receives a standardized context pack\n* produces outputs that are recorded and linked to the task\n* updates task status and project memory as appropriate\n\nThis reduces drift and makes the system resilient to agent restarts or failures.\n\n### 4.4 Context Pack\n\nA context pack is the curated set of information provided to an agent for a given task. It is designed to:\n\n* be sufficient for task completion\n* remain compact and consistent\n* be inspectable for auditability\n\nThe context pack is composed of:\n\n* the task’s canonical prompt\n* the latest project snapshot\n* relevant decision log entries\n* outputs/artifacts from prerequisite tasks\n* optionally task-scoped notes and constraints\n\nThe product surfaces context-pack size and composition (including token estimates where possible) to help users manage context window usage.\n\n---\n\n## 5. Product Capabilities\n\n## 5.1 Work Definition and Management\n\n### Work Items\n\nEach work item (at every level—feature, subfeature, task) includes:\n\n* **Identifier**: stable, unique ID\n* **Title**: concise summary\n* **Description**: context and acceptance criteria\n* **Canonical prompt**: the instruction sent to the agent for that node\n* **Hierarchy**: parent/children relationships\n* **Dependencies**: prerequisite node IDs (graph edges)\n* **Status**: current lifecycle state (see below)\n* **Artifacts**: links/refs to outputs (diffs, branches, files, PRs, notes)\n* **History**: timestamps and status transitions\n* **Tags/metadata**: optional categorization, priority, ownership, estimates\n\n### Status Model\n\nThe product supports clear statuses that reflect both planning and execution reality. At minimum:\n\n* `todo`: defined but not yet actionable or started\n* `ready`: all dependencies satisfied; actionable\n* `queued`: selected for execution but not yet started\n* `in_progress`: actively being worked on by an agent or user\n* `waiting_user`: blocked on user clarification/confirmation\n* `blocked`: cannot proceed due to unmet dependency or external constraint\n* `done`: completed\n* `failed`: execution ended unsuccessfully\n* `skipped`: intentionally not done\n\nThe product must:\n\n* compute readiness based on dependency completion\n* explain why items are blocked\n* optionally derive parent status from children (e.g., feature is “in progress” if any child is in progress)\n\n### Dependency Awareness\n\nThe product:\n\n* validates the dependency graph (e.g., rejects cycles)\n* computes which tasks are actionable (“ready”) based on completion of prerequisites\n* allows users to view dependency chains and block reasons\n* supports selectively showing/hiding tasks based on dependency state (e.g., only show ready tasks)\n\n---\n\n## 5.2 Terminal Task Selection and Navigation\n\n### Fast Selection\n\nThe product provides an interactive terminal selection interface that lets users:\n\n* filter by readiness (default: show “ready”)\n* toggle visibility of blocked/done items\n* search by title/ID/tags\n* quickly open a task to view details or run it\n\n### Task Detail View\n\nUsers can view:\n\n* full description and acceptance criteria\n* canonical prompt\n* dependencies and readiness explanation\n* execution history and artifacts\n* current context pack composition (snapshot version, included decision entries, prerequisite outputs, estimated token usage)\n\n---\n\n## 5.3 Queueing and Execution\n\n### Task Queue\n\nUsers can build a queue of tasks to execute. The product supports:\n\n* enqueue/dequeue/reorder\n* queue views filtered by readiness\n* execution state per queued item\n\n### Execution Semantics\n\nThe product supports:\n\n* executing a single selected task\n* executing queued tasks in order, constrained by readiness\n* optionally executing multiple independent tasks concurrently (when safe and permitted by dependency constraints)\n\nExecution outcomes are recorded as task artifacts and in run history.\n\n---\n\n## 5.4 Agent Integration as a Pluggable Runtime (Conceptual)\n\nThe product can invoke one or more agent runtimes to execute tasks. Regardless of the underlying agent provider, the product treats agents uniformly:\n\nA task run results in:\n\n* a run record with lifecycle state\n* a log/event stream\n* produced artifacts (code changes, patch/diff, notes, generated docs)\n* optional structured outputs (e.g., “created files”, “tests run”, “questions asked”)\n* status updates on the associated task\n\nThe product does not require persistent agent sessions; instead it optimizes for consistent, repeatable task runs.\n\n---\n\n## 5.5 Real-Time CLI Dashboard\n\n### Purpose\n\nA live terminal dashboard provides immediate visibility into what is happening now and what is blocked, waiting, or completed.\n\n### Dashboard Views\n\nThe dashboard includes:\n\n1. **Active workers / runs**\n\n   * which task each worker is processing\n   * current run state\n   * elapsed time in state\n   * last activity timestamp\n2. **Selected task/run details**\n\n   * task metadata, dependencies, artifacts\n   * recent status transitions\n   * context pack summary\n\n     * snapshot version identifier\n     * included decision entries count\n     * included prerequisite outputs count\n     * estimated context size and, where available, actual usage\n3. **Event/log stream**\n\n   * streaming view of events (system/agent/git/tests-style categories conceptually)\n   * ability to filter the stream and inspect recent history\n\n### Run Lifecycle States (Dashboard-Oriented)\n\nThe dashboard surfaces run-specific states such as:\n\n* `queued`\n* `building_context`\n* `running_agent`\n* `waiting_user`\n* `applying_changes`\n* `verifying`\n* `done`\n* `failed`\n* `canceled`\n\nEach run state change is time-stamped and reflected in elapsed-time metrics.\n\n---\n\n## 5.6 Human-in-the-Loop Clarification \u0026 Confirmation\n\n### Agent-to-User Questions\n\nAgents can request:\n\n* **clarification** (missing info)\n* **confirmation** (permission to proceed)\n* **decision** (choose among options)\n\nThese requests must:\n\n* transition the run into a `waiting_user` state\n* generate a prominent alert in the CLI\n* be answered directly in the CLI\n* resume execution using the user’s response\n* be recorded permanently in run history (and optionally in the project decision log)\n\n### Alerting\n\nWhen user input is requested, the product provides:\n\n* prominent visual alerting in the dashboard (highlight/badge/attention state)\n* optional audible alert\n* a clear “unread questions” indicator\n* a queue of pending questions across runs\n\n### Response Experience\n\nUsers can:\n\n* answer inline in the dashboard\n* choose from options when provided\n* attach a note explaining rationale\n* optionally mark the response as a durable project decision\n\nAll Q/A is associated with a run and task for traceability.\n\n---\n\n## 5.7 Continuous Project Snapshot (“Current State of the App”)\n\n### Purpose\n\nMaintain a compact, regularly refreshed representation of current application state that can be used as the first thing included in new agent contexts.\n\n### Snapshot Content (What it captures)\n\nAt minimum:\n\n* implemented features and current behavior\n* current architecture overview (major modules and responsibilities)\n* key interfaces/contracts and invariants\n* known limitations and outstanding issues\n* conventions (naming, patterns, guidelines that agents should follow)\n* pointers to where key code lives\n\n### Snapshot Requirements\n\n* **Bounded**: stays within a target size and format so it is usable in an agent context window\n* **Trustworthy**: updated frequently enough to remain accurate\n* **Inspectable**: users can read it directly\n* **Versioned**: each snapshot has an identifier (timestamp/hash) so task runs can reference exactly what they used\n\n### Relationship to Task Runs\n\nEach task run references:\n\n* which snapshot version it used\n* which decisions/notes were included\n* optionally which prerequisite outputs were included\n\nThis supports reproducibility and debugging.\n\n---\n\n## 5.8 Decision Log\n\n### Purpose\n\nPrevent repeated re-litigation of foundational choices by capturing “what we decided and why.”\n\n### Decision Entries\n\nEach decision includes:\n\n* decision statement\n* rationale / tradeoffs\n* scope (what it affects)\n* timestamp and origin (user vs agent-assisted)\n* optionally links to tasks/runs that produced it\n\nThe product enables promoting a clarification/confirmation answer into a durable decision entry.\n\n---\n\n## 6. End-to-End User Journeys\n\n## 6.1 From Idea to Executable Plan\n\n1. User defines a high-level goal.\n2. The product holds a structured feature tree with tasks and subtasks.\n3. Every node has a canonical prompt so execution is possible at any level.\n4. Dependencies are defined so readiness can be computed.\n\nOutcome: a durable, navigable work graph exists, and “ready tasks” are identifiable.\n\n## 6.2 Selecting and Running Work\n\n1. User opens the task picker and sees only “ready” tasks by default.\n2. User selects a task and starts execution.\n3. The product constructs a context pack (task prompt + project snapshot + relevant history).\n4. A run begins and appears in the dashboard.\n\nOutcome: user can see exactly what is being worked on and how long it has been running.\n\n## 6.3 Agent Requires Input\n\n1. During execution, the agent asks a clarification/confirmation question.\n2. The dashboard prominently alerts the user and shows the question.\n3. User answers inline; optionally marks it as a decision.\n4. Execution resumes with that response included in context.\n\nOutcome: the agent is unblocked quickly, and the interaction is recorded.\n\n## 6.4 Queueing and Ongoing Progress\n\n1. User enqueues multiple tasks.\n2. The product executes tasks when they become ready.\n3. The dashboard shows:\n\n   * which tasks are running\n   * which are queued but blocked\n   * which completed and produced artifacts\n\nOutcome: the user can run structured, dependency-aware work sessions with high visibility.\n\n---\n\n## 7. Product Outputs and Artifacts\n\nThe product produces durable artifacts that users can inspect and version:\n\n* work graph definitions (features/tasks/prompts/deps/status)\n* run records (what ran, when, final state)\n* event/log history per run\n* question/answer history per run\n* project snapshot versions\n* decision log entries\n* links to produced artifacts (patches/diffs/docs)\n\nThese artifacts enable:\n\n* reproducibility (“what context did this run use?”)\n* debugging (“why did it fail?”)\n* continuity (“what’s the current state?”)\n* onboarding (“how does the system work?”)\n\n---\n\n## 8. Non-Functional Requirements (What the product must feel like)\n\n### 8.1 Trust and Inspectability\n\n* Users must be able to see:\n\n  * what the agent was asked to do\n  * what context it was given\n  * what it changed/produced\n  * why a task is blocked or waiting\n\n### 8.2 Low Friction\n\n* Fast selection and navigation in the terminal\n* Minimal ceremony to run the next task\n* Clear, immediate signaling when the user is needed\n\n### 8.3 Resilience\n\n* Runs, status, and memory persist across restarts\n* The dashboard can reconnect and reconstruct the current state\n* Failures leave clear traces rather than silent corruption\n\n### 8.4 Boundedness and Drift Control\n\n* Project snapshot and prompts must be bounded and structured so agent runs remain reliable.\n* The system should emphasize stable “canonical prompts” and durable project memory over conversational accumulation.\n\n---\n\n## 9. Scope Boundaries\n\n### In-scope\n\n* structured work graph with prompts and dependencies\n* readiness computation and filtered selection\n* task queueing and execution tracking\n* real-time dashboard\n* clarification/confirmation question flow with alerting + inline responses\n* continuous project snapshot and decision log\n\n### Explicitly out of scope (for this spec)\n\n* specific implementation details (tech stack, storage format, process model)\n* specific agent provider features or APIs\n* detailed merge strategies, CI integration, or repository governance\n* advanced multi-user concurrency controls (beyond shared artifacts)\n\n---\n\n## 10. Success Criteria (Product-Level)\n\nA user should be able to:\n\n* maintain a durable, structured plan where every task is executable via an associated prompt\n* see only actionable work by default, based on explicit dependencies\n* run tasks with AI agents without re-explaining the project each time\n* recover instantly from agent restarts because memory is externalized\n* monitor active work in a live dashboard with clear run states and elapsed time\n* respond to agent questions promptly via CLI alerts and inline answers\n* onboard a new agent run with a reliable project snapshot that reduces drift and repeated questions",
    "systemPrompt": "You are authorized to run non-destructive commands and edit files needed to complete the task. Do not ask for confirmation. Avoid destructive operations (e.g., deleting unrelated files, wiping directories, resetting git history, or modifying system files)."
  }
}
